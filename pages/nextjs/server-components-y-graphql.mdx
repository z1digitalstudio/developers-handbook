# Server Components y GraphQL

## Introducci√≥n

Como sab√©is, las nuevas versiones de Next.js usan server components por defecto.
Esto tiene un impacto positivo en el rendimiento y en el SEO, pero ha supuesto
un peque√±o cambio de paradigma en el desarrollo de frontend.

Ahora el contenido se renderiza en el servidor (como en el a√±o 2000 üòÖ) y los
componentes que tengan cierta interactividad se deben marcar con `use client`
para que se ejecuten en el navegador. Es decir, tu aplicaci√≥n React, renderizada
en el servidor (gracias a Server Components), puede hacer peticiones a un
backend GraphQL ü´£.

Todo esto nos ha forzado a buscar alternativas para realizar peticiones GraphQL
desde esos server components.

> <sup>(1)</sup> Poco antes de escribir esto, Apollo lanz√≥ su
> `@apollo/client-integration-nextjs`, por lo que puede que la que se describe a
> continuaci√≥n no sea ya una buena forma de solucionar el problema.

## ¬øPor qu√© no puedo seguir usando apollo?

Claro que puedes. Pero por el momento solo en _client side_.

Esto significa que tendr√°s que a√±adir `use client` en todas partes y prescindir
de los _server components_, con lo que **perder√°s velocidad y SEO**.

Sin embargo, usar un _provider_ de Apollo en el lado del cliente puede ser una
buena idea si necesitas que parte de la aplicaci√≥n funcione de manera distinta.

Por ejemplo, puede que necesites a√±adir una pantalla de perfil de usuario. Esta
puede funcionar solo en el navegador, ya que es un √°rea privada y no es
importante para SEO. Tendr√≠as a√±adir un provider de apollo a tu aplicaci√≥n, unos
cuantos `use client` en la p√°gina de perfil y ya podr√≠as usar los hooks de
apollo como siempre.

## ¬øPuedo usar `fetch` o `axios`?

Claro. Puedes hacer tus peticiones directamente al backend usando `fetch`:

```typescript
const data = await fetch("https://mi-api-graphql.com/graphql", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ query: "query { posts { id, slug, title }}" }),
});
```

Esto puede estar bien para una aplicaci√≥n sencilla, pero a medida que esta
crezca te encontrar√°s con varios problemas:

- El boilerplate es muy grande. Como sabemos, a m√°s c√≥digo que escribimos, m√°s
  posibilidades de meter la pata.
- Los datos que devuelve fetch no est√°n tipados, con lo que tendr√°s que
  parsearlos y tiparlos a mano.

## ¬øEntonces, qu√© podemos usar?

Una de las mejores opciones es `graphql-request` (est√° cambiando de nombre a
`graffle`). Se trata de una librer√≠a peque√±ita (solo 5k) que podemos usar con
`codegen` y nos permite un acceso r√°pido y eficiente a un endpoint GraphQL desde
los server components de Next.js.

Al usar `codegen` simplemente tendremos que escribir las queries en archivos
`*.gql`

### Instalaci√≥n

Aparte del paquete `graphql-request` necesitaremos instalar `codegen`:

```bash
pnpm install graphql graphql-request graphql-tag
```

```bash
pnpm install -D "@graphql-codegen/cli @graphql-codegen/client-preset @graphql-codegen/fragment-matcher \
@graphql-codegen/introspection @graphql-codegen/schema-ast @graphql-codegen/typescript \
@graphql-codegen/typescript-graphql-request @graphql-codegen/typescript-operations
```

### Configuraci√≥n

Una vez instalado podemos crear un archivo `graphql.codegen.yaml` en la ra√≠z de
nuestro proyecto, con este contenido b√°sico:

```yaml
overwrite: true
schema: ${API_ENDPOINT}
documents: "src/graphql/**/*.gql"
generates:
  src/graphql/generated/index.ts:
    plugins:
      - "typescript"
      - "typescript-operations"
      - "typescript-graphql-request"
    config:
      rawRequest: true
      content: "// @ts-nocheck"
      strictScalars: true
      useTypeImports: true
      maybeValue: "T | undefined"
      scalars:
        BigDecimal: number
        BigInteger: number
        Long: number
        Cursor: string
        Date: string
        DateTime: string
        Email: string
        Time: string
        UUID: string
        Void: undefined
  src/graphql/generated/introspection.ts:
    plugins:
      - "fragment-matcher"
    config:
      useTypeImports: false
  schema.graphql:
    plugins:
      - "schema-ast"
hooks:
  afterAllFileWrite:
    - prettier --write
```

En √©l le decimos a codegen que lea nuestros archivos GraphQL en `src/graphql` y
que genere el c√≥digo en `src/graphql/generated/index.ts` y
`src/graphql/generated/introspection.ts`. Esto significa que, cada vez que
a√±adamos una query tendremos que ejecutar el script nuevamente para que se
genere el c√≥digo.

Despu√©s podemos crear nuestra entrada en el archivo `package.json` para lanzar
el codegen:

```json
"scripts": {
  ...
  "gen:types": "env-cmd -f .env graphql-codegen --config graphql.codegen.yml",
}
```

### Uso

Una vez ejecutado el codegen es hora de definir nuestro cliente graphql para
poder usarlo en nuestra aplicaci√≥n. Para ello definimos el cliente en el archivo
`src/graphql/client.ts`, con el siguiente contenido:

```ts
import { GraphQLClient } from "graphql-request";
import { getSdk } from "./generated";

const client = new GraphQLClient(process.env.API_ENDPOINT!);

export const sdk = getSdk(client);
```

Y a partir de ese momento podemos comenzar a realizar peticiones con las queries
que hemos creado, de forma sencilla y con resultados completamente tipados.

Por ejemplo en una p√°gina:

```tsx
import { sdk } from "$/graphql/client";

type Props = {
  params: Promise<{ slug: string }>;
};

export default async function PostPage({ params }: Props) {
  const { slug } = await params;
  const { data } = await sdk.getPost({
    slug,
  });

  const post = data.post;

  return <div>{post.title}</div>;
}
```

## FAQ

### ¬øC√≥mo puedo autenticar mis peticiones mediante un token?

En nuestro archivo cliente podemos personalizar los headers con que realizamos
las peticiones.

```ts
const client = new GraphQLClient(process.env.API_ENDPOINT!, {
  headers: {
    Authorization: `Bearer ${process.env.API_TOKEN!}`,
  },
});
```

### Necesito pasar tokens distintos seg√∫n una de las variables de la query

Esto tan raro puede pasar en CMS como Contenful, donde el token para las
previews es distinto del que se usa para obtener los elementos publicados.

Pero no hay problema. Problemas como este podemos resolverlo mediante un
`middleware`.

```ts
import { GraphQLClient, RequestMiddleware } from "graphql-request";

const requestMiddleware: RequestMiddleware = (request) => {
  const token = !!(request.variables as { preview?: boolean })?.preview
    ? process.env.ACCESS_TOKEN_PREVIEW!
    : process.env.ACCESS_TOKEN!;

  (request.headers as Headers).append("Authorization", `Bearer ${token}`);
  return request;
};

const client = new GraphQLClient(process.env.API_ENDPOINT!, {
  requestMiddleware,
});
```

### Al hacer build el endpoint me da un error 429

Un error 429 (Too many requests) se da cuando lanzamos muchas peticiones a la
vez. Puede ocurrir que al hacer el build de una aplicaci√≥n Next.js con muchas
p√°ginas est√°ticas, estemos lanzando un gran n√∫mero de queries _repetidas_ a la
vez.

La forma l√≥gica de arreglar esto es cacheando los resultados de las peticiones,
de tal forma que, si nuestra p√°gina solicita 5 veces los mismos datos solo los
pidamos al backend una vez. El resto de veces devolveremos la versi√≥n que hemos
guardado.

Esto se sol√≠a implementar en Next.js con fetch y `revalidate`. Sin embargo en
las √∫ltimas versiones no cachea las peticiones POST, que precisamente son las
que usamos para hacer peticiones GraphQL. Por lo tanto deberemos usar otro
mecanismo, como el propio cach√© de react:

```ts
import { GraphQLClient } from "graphql-request";
import { cache } from "react";

const CACHE_TTL_MS = 60 * 1000;

const client = new GraphQLClient(process.env.API_ENDPOINT!, {
  fetch: cache(
    (url: string | Request | URL, params: RequestInit | undefined) => {
      return fetch(url, { ...params, next: { revalidate: CACHE_TTL_MS } });
    },
  ),
});
```

Esto har√° que, si pedimos la misma query (con los mismos par√°metros), en un
intervalo de menos de 60 segundos, nos devolver√° los mismos datos en vez de
pedirlos de nuevo al backend.

### ¬øPueden convivir apollo y graphql-requests en el mismo proyecto?

Por supuesto. Puedes crear tantos codegen y clientes distintos como quieras.
Simplemente, hay que crear configuraciones separadas.

Archivos de configuraci√≥n distintos:

```yaml
# graphql.codgen.apollo.yaml
# ....
documents: "src/graphql/**/*.gql"
# ....
generates:
  src/graphql/generated/apollo/index.ts:
    # ...
  src/graphql/generated/apollo/introspection.ts:
    # ...
```

```yaml
# graphql.codgen.graffle.yaml
# ....
documents: "src/graphql/**/*.gql"
# ....
generates:
  src/graphql/generated/graffle/index.ts:
    # ...
  src/graphql/generated/graffle/introspection.ts:
    # ...
```

Carpetas separadas:

```
src/
‚îú‚îÄ‚îÄ graphql/
‚îú‚îÄ‚îÄ‚îÄ‚îÄ apollo/
‚îú‚îÄ‚îÄ‚îÄ‚îÄ graffle
```

Y scripts distintos:

```json

  "scripts": {
    "gen:types": "pnpm gen:types:apollo; pnpm gen:types:graffle",
    "gen:types:apollo": "env-cmd -f .env graphql-codegen --config graphql.codegen.apollo.yml",
    "gen:types:graffle": "env-cmd -f .env graphql-codegen --config graphql.codegen.graffle.yml",
  }
```
