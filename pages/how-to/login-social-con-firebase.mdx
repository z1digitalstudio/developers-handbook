# Login Social con Firebase

Muchas veces resulta complicado configurar el login con Apple o Google. Esta
peque침a gu칤a explica como hacerlo de forma sencilla con Firebase.

Estos pasos est치n pensados para un backend con Django y un frontend con React,
pero seguro que puedes hacerlo con cualquier otro framework.

## Crea un proyecto en Firebase.

Abre [Firebase](https://console.firebase.google.com) y crea un nuevo proyecto.
Luego crea una nueva **app web** en ese proyecto. Firebase te dar치 unos valores
de configuraci칩n parecidos a estos:

```js
{
  apiKey: "xxxxxxxxxx-xxxxxxxxxxxxxx-xxxxxxxxxxxxx",
  authDomain: "xxxxxx.firebaseapp.com",
  projectId: "xxxxxx",
  storageBucket: "xxxxxx.firebasestorage.app",
  messagingSenderId: "12345678901",
  appId: "1:12345678901:web:xxxxxxxxxxxxxxxxxxxxxx"
};
```

Gu치rdalos. Los usar치s en tu frontend.

### Configura el login con Google y Apple.

Ahora busca "Authentication" en el panel de la izquierda y selecciona "M칠todos
de acceso". A침ade los que necesites.

Despu칠s navega a configuraci칩n (tambi칠n dentro de "Authentication") y en
"Dominios autorizados" a침ade los que necesites en tu aplicaci칩n.

Si a침ades Apple necesitas crear un nuevo proyecto en Apple Developer, e
introducir ciertos valores.

#### Pasos adicionales para Apple

Para configurar Apple necesitas crear un nuevo proyecto en Apple Developer.
Luego, al habilitar el login con Apple en Firebase, deber치s rellenar algunos
datos adicionales:

- ID de servicios
- ID del equipo
- ID de clave
- Clave privada

### Obt칠n la cuenta de servicio para usar en tu backend.

En la configuraci칩n general de Firebase, busca "Cuentas de servicio" y crea una
nueva calve privada. Esto generar치 un archivo `.json` que se descargar치
autom치ticamente. Gu치rdalo para usar luego en el backend.

## Configura tu backend.

Suponiendo que usas un backend con Django y GraphQL, puedes empezar con una
mutaci칩n sencilla como esta:

```python

import firebase_admin
from firebase_admin import auth as firebase_auth
from firebase_admin import credentials


if not firebase_admin._apps and settings.FIREBASE_SERVICE_ACCOUNT:
    cred = credentials.Certificate(settings.FIREBASE_SERVICE_ACCOUNT)
    firebase_admin.initialize_app(cred)

@strawberry.input
class FirebaseLoginInput:
    token: str

class Mutation:

    [...]

    @strawberry.mutation
    def firebase_login(self, info: Info, input: FirebaseLoginInput) -> UserType:
        decoded_token = firebase_auth.verify_id_token(input.token)
        email = decoded_token.get("email", "")
        if not email:
            raise Exception(WRONG_CREDENTIALS)

        user, created = User.objects.get_or_create(email=email)
        login(info.context.request, user)

        user.last_login = timezone.now()
        user.save()

        return user
```

En tus settings deber칤as tener algo como esto:

- Si usas environment variables:

```python
FIREBASE_SERVICE_ACCOUNT = {
    "type": os.getenv("FIREBASE_TYPE"),
    "project_id": os.getenv("FIREBASE_PROJECT_ID"),
    "private_key_id": os.getenv("FIREBASE_PRIVATE_KEY_ID"),
    "private_key": os.getenv("FIREBASE_PRIVATE_KEY", "").replace("\\n", "\n"),
    "client_email": os.getenv("FIREBASE_CLIENT_EMAIL"),
    "client_id": os.getenv("FIREBASE_CLIENT_ID"),
    "auth_uri": os.getenv("FIREBASE_AUTH_URI"),
    "token_uri": os.getenv("FIREBASE_TOKEN_URI"),
    "auth_provider_x509_cert_url": os.getenv("FIREBASE_AUTH_PROVIDER_X509_CERT_URL"),
    "client_x509_cert_url": os.getenv("FIREBASE_CLIENT_X509_CERT_URL"),
    "universe_domain": os.getenv("FIREBASE_UNIVERSE_DOMAIN"),
}
```

- O si usas AWS Secrets Manager:

```python
FIREBASE_SERVICE_ACCOUNT = {
    "type": secrets.get_secret("FIREBASE_TYPE"),
    "project_id": secrets.get_secret("FIREBASE_PROJECT_ID"),
    "private_key_id": secrets.get_secret("FIREBASE_PRIVATE_KEY_ID"),
    "private_key": secrets.get_secret("FIREBASE_PRIVATE_KEY").replace("\\n", "\n"),
    "client_email": secrets.get_secret("FIREBASE_CLIENT_EMAIL"),
    "client_id": secrets.get_secret("FIREBASE_CLIENT_ID"),
    "auth_uri": secrets.get_secret("FIREBASE_AUTH_URI"),
    "token_uri": secrets.get_secret("FIREBASE_TOKEN_URI"),
    "auth_provider_x509_cert_url": secrets.get_secret(
        "FIREBASE_AUTH_PROVIDER_X509_CERT_URL"
    ),
    "client_x509_cert_url": secrets.get_secret("FIREBASE_CLIENT_X509_CERT_URL"),
    "universe_domain": secrets.get_secret("FIREBASE_UNIVERSE_DOMAIN"),
}
```

Los valores de los secrets est치n en el archivo json que te descargaste de
Firebase, al crear la cuenta de servicio.

## Configura tu frontend.

En fronted tambi칠n necesitas algunas variables de entorno. Son las que te mostr칩
Firebase en el primer paso, al crear la app web. Una vez configuradas, puedes
usar un hook como este:

```ts
import { useFirebaseLoginMutation } from "$/graphql/generated/apollo";

import { getApp, getApps, initializeApp } from "firebase/app";
import {
  GoogleAuthProvider,
  OAuthProvider,
  getAuth,
  signOut,
  signInWithPopup,
} from "firebase/auth";
import { useRouter, useSearchParams } from "next/navigation";
import { useState } from "react";

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY!,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN!,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID!,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET!,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID!,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID!,
};

// Avoid multiple initialization
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();

const auth = getAuth(app);

export function useFirebaseLogin({
  afterLoginRedirect,
}: {
  afterLoginRedirect: string;
}) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const redirect = searchParams.get("redirect");
  const [isLoading, setIsLoading] = useState(false);
  const [performFirebaseLoginMutation] = useFirebaseLoginMutation();

  const performLoginAndRedirect = async (token: string) => {
    await performFirebaseLoginMutation({
      variables: { input: { token } },
    });

    router.push(redirect || afterLoginRedirect);
  };

  const handleGoogleLogin = async () => {
    try {
      setIsLoading(true);
      const provider = new GoogleAuthProvider();
      const result = await signInWithPopup(auth, provider);
      const token = await result.user.getIdToken();

      if (token) {
        await performLoginAndRedirect(token);
      }
      setIsLoading(false);
    } catch (error) {
      console.error(error); // show toast?
    } finally {
      setIsLoading(false);
    }
  };

  const handleAppleLogin = async () => {
    try {
      setIsLoading(true);
      const provider = new OAuthProvider("apple.com");
      provider.addScope("email");

      const result = await signInWithPopup(auth, provider);
      const user = result.user;
      const token = await user.getIdToken();

      if (token) {
        await performLoginAndRedirect(token);
      }
    } catch (error) {
      console.error(error); // show toast?
    } finally {
      setIsLoading(false);
    }
  };

  const handleFirebaseLogout = async () => {
    await signOut(auth);
  };

  return {
    handleGoogleLogin,
    handleAppleLogin,
    handleFirebaseLogout,
    isLoading,
  };
}
```

En 칠l simplemente se obtiene el token de Firebase y lo pasamos al backend. El
backend se encarga de comprobar el token y crear o actualizar el usuario. As칤 de
simple.

Ahora simplemente usa este hook y llama al "handle" que corresponda en tus
botones de login. Recuerda llamar a `handleFirebaseLogout` antes de hacer logout
de tu aplicaci칩n, para borrar tambi칠n la sesi칩n en firebase.

Y listo. Sencillito. O no?

## Entonces llego ...Safari 游땬

Safari bloquea las cookies de terceros. Es decir, si tu web y firebase no est치n
en el mismo dominio no funcionar치. Tienes 2 opciones (bueno 3):

- **No soportar Safari**. Esta es la que m치s me gustar칤a poder implementar.

- **Usar firebase hosting**. Si _hosteas_ tu web en firebase este problema
  desaparecer치, porque todo estar치 en un mismo dominio (tu web y firebase).

- **Usar un proxy**. Puedes configurar un proxy para cargar la api de firebase
  en el mismo dominio que tu web. Con esto no habr치 problemas de cookies, pero
  necesitar치s configurar algunas urls adicionales en tus proveedores de Auth0.

### 1. Configura tu proxy.

En general deber치s a침adir un proxy inverso hacia tu dominio de authenticaci칩n de
firebase. El dominio es el que aparece en la configuraci칩n general que obtuviste
al crear tu app, en el campo `authDomain`.

La forma de hacerlo puede variar dependiendo de la plataforma.

#### Next.JS

En Next.js puedes a침adir un proxy en el archivo `next.config.js`:

```js
module.exports = {
  async rewrites() {
    return [
      {
        source: '/__/auth/:path*',
        destination: `https://xxxx.firebaseapp.com/__/auth/:path*`,
      }
    ];
  }
```

#### Railway con SPA

Railway con SPA utilizar por defecto [Caddy](https://caddyserver.com/) como
servidor web, por lo que deber치s configurar el proxy en tu `Caddyfile`. Este es
un ejemplo para React con Vite:

```
# Caddyfile
:{$PORT:8080} {
	handle /__/auth/* {
		reverse_proxy https://{$FIREBASE_ORIGINAL_AUTH_DOMAIN} {
			header_up Host {http.reverse_proxy.upstream.hostport}
      header_up X-Forwarded-Host {host}
      header_up X-Forwarded-Proto {scheme}
		}
	}

	handle {
		root * {$STATIC_PATH:/app/dist}
		try_files {path} /index.html
		file_server
	}
}
```

Recuerda a침adir la variable `FIREBASE_ORIGINAL_AUTH_DOMAIN` con el valor
original de tu `authDomain` a tu configuraci칩n de railway, o simplemente
_hard-codearla_ en el archivo.

**Importante:** al momento de escribir esto hay un bug en la UI de railway, por
lo que deber치s a침adir el fichero `railway.json` para forzar el uso de _Railpack_
como builder:

```json
{
  "build": {
    "builder": "RAILPACK"
  }
}
```

### 2. Configura tu web.

Al mismo tiempo deber치s modificar `authDomain`, que en nuestro caso es la
variable de entorno `NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN`, y poner el dominio de tu
web.

As칤, las peticiones de firebase se cargan en tu dominio.

### 3. A침ade el dominio a la configuraci칩n de cada proveedor de Auth0.

S칤, tendr치s que a침adir el dominio a **todos** los proveedores de Auth0.

#### Google:

Entra en [Google Cloud console](https://console.cloud.google.com) y busca el
proyecto en cuesti칩n. Se habr치 creado al crear la app en firebase.

Ahora localiza el apartado "Credenciales" (puedes buscarlo). Dentro, ver치s una
secci칩n llamada "IDs de clientes de OAuth 2.0". Identifica tu cliente (ser치 de
tipo Web) y modif칤calo.

En el apartado "URIs de redireccionamiento autorizados" a침ade las que necesites.
Deber치s inclu칤r el dominio y la ruta del proxy. Por ejemplo:

`https://www.example.com/__/auth/handler`

#### Apple:

Entra en la cuenta de Apple developer, y en la configuraci칩n de "Sign with
Apple" podr치s a침adir las rutas que necesites.

C칩mo con google, deber치s inclu칤r el dominio y la ruta del proxy. Por ejemplo:

`https://www.example.com/__/auth/handler`
