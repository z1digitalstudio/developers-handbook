# Typescript tips

---
- üá™üá∏ Idioma: Espa√±ol
- üò∏ Autores: Mar√≠a Sim√≥
- üóìÔ∏è Creado: 03/03/2023

---

Recursos:
https://www.typescriptcourse.com/articles
https://basarat.gitbook.io/typescript/
https://www.totaltypescript.com
TS Crash course: https://www.youtube.com/watch?v=p6dO9u0M7MQ
TS Tips and tricks (advanced): https://www.youtube.com/watch?v=hBk4nV7q6-w

matt pococks on youtube - learn w jason

Tools: 
- https://github.com/millsp/ts-toolbelt
- total typescript reset


Guia nueva
- npmp
- apollo codegen
- next 13
- testing setup


## TL;DR
- Problemas comunes de Typescript que podemos encontrar en nuestros proyectos
- Recomendaci√≥n typescript-reset y typescript-utils
- Visibilidad que problemas solucionamos
- Recursos


- Unions
- Narrowing
- Type predicates
- Como tipar un reduces
- As y satisdies
- Any
- Returned types
- Gen√©ricos
- Function signature
- Tipos condicionales
- Utils de typescript


- Montar escenarios de Typescript: Recetario
- As
- Any
- Tipar un reduce
- Gen√©rico
- Preguntar a los compis
- Returned types
- Tipar una funci√≥n
- Type predicates
- Discriminar uniones
- Tipos condicionales
- https://www.benmvp.com/blog/filtering-undefined-elements-from-array-typescript/
- Clases de matt



Publicar en dev, poner por twitter y decir que tambi√©n lo he subido al blog



## Type transformation
- keyof
- unions to arrays and objects
- enums to arrays and objects
- object to union
- unions vs enums


### types from types
https://www.typescriptlang.org/docs/handbook/2/types-from-types.html


- typeof https://www.typescriptlang.org/docs/handbook/2/typeof-types.html
- keyof https://www.typescriptlang.org/docs/handbook/2/keyof-types.html
- utility types https://www.typescriptlang.org/docs/handbook/utility-types.html (custom)
- typing promises https://www.totaltypescript.com/tutorials/beginners-typescript/typing-promises-and-async-requests
- unions https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types
- discriminate unions
- as const
- indexed access types
- template literal types https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html
- mapped types https://www.typescriptlang.org/docs/handbook/2/mapped-types.html
- discriminated unions https://basarat.gitbook.io/typescript/type-system/discriminated-unions
- template literal types https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html
- generics https://www.totaltypescript.com/mental-model-for-typescript-generics


Typescript es un superset de Javascript. Es un a√±adido. Es una herramienta de desarrollo. Nuestro c√≥digo final, que pongamos en producci√≥n, nunca va a ser typescript, se va a compilar javascript. Usamos Ts durante la fase de desarrollo para aportar robustez a nuestro c√≥digo, detectar errores, tener autocompletado, alinearnos con la API tipada que recibimos de back, porque GraphQL es una especificaci√≥n esencialmente tipada.

TS a√±ade "tipos" a JS. ¬øQu√© son los tipos?
- Son anotaciones que a√±adimos al c√≥digo para declarar de qu√© tipo son nuestros datos.
- Javascript es un lenguaje de tipado d√©bil y din√°mico
- Aumentan nuestra velocidad en el refactoring, nos ayudan a cazar errores en runtime
- Son una buena forma de documentaci√≥n. Una de las mejores formas de saber lo que una funci√≥n hace (tmabien de escribirla) es tener tipado su input y su output: "The function signature is the theorem and the function body is the proof"
- TypeScript is just JavaScript with docs.
- Es un linter con informaci√≥n de tipos

![[Screenshot 2023-03-04 at 09.41.14.png|300]]


### Adopci√≥n de TS y niveles de uso
Moverse a TS es m√°s f√°cil de lo que parece por dos razones:
- Sigue siendo Javascript
- Tiene una adopci√≥n incremental (aceptar any de forma impl√≠cita o expl√≠cita)
- Tipos impl√≠citos e inferidos


Esta es la raz√≥n por la que muchos convivimos con Ts en nuestro desarrollo diario en diferentes grados, sabiendo m√°s o menos como funciona. Trabajando con √©l o alrededor de √©l. 

Typescript es muy flexible, su prioridad va a ser que podamos trabajar de la manera m√°s f√°cil y segura con Javascript. El nos va a devolver en seguridad y auto-completado tanto como nosotros le demos. 

- Tipos expl√≠citos:
En muchas ocasiones podemos confiar en la inferencia de tipos de TS. En otras queremos ser expl√≠citos, para asegurarnos un determinado tipo en nuestros datos, ser intencionales, documentar.

La manera m√°s sencilla de tipar es usar una anotaci√≥n de este tipo:

```
let name: string = "Greta"

name = 2 // Error: cannot assign a `number` to a `string`
```

- Tipos estructurales
Los tipos de TS son estructurales, para reducir la carga cognitiva que supone TS al m√°ximo. 
Una funci√≥n/componente va a aceptar cualquier tipo que cumpla el contrato, aunque el valor que pasemos tenga propiedades adicionales. Nunca puede tener de menos, pero s√≠ dem√°s.

### Ts type system

- Enum. Colecci√≥n de valores relacionados. 
	- Number enums, cuando no asignamos un valor a los miembros del enum
```
enum Z1 {
  Product,
	Design,
	Backend,
	Frontend,
}


const area1: Z1 = 0 // valid
const area2: Z1 = Z1.Product // valid
console.log(area1 === area2) // true
```

- Mas tipos:
	- String enums
	- Cons enums, pueden suponer un boost de performance, porque no se compilan en runtime
	
```
const enum Options {
	False
	True
	Unknown
}

const isTrue = Options.False

// compirala a 
const isTrue = 0
```

El valor del miembro del enum se calcula en l√≠nea y no se genera Javascript para el enum.

A√±adir un m√©todo al enum:
```
enum Weekday {
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
}
namespace Weekday {
    export function isBusinessDay(day: Weekday) {
        switch (day) {
            case Weekday.Saturday:
            case Weekday.Sunday:
                return false;
            default:
                return true;
        }
    }
}

const mon = Weekday.Monday;
const sun = Weekday.Sunday;
console.log(Weekday.isBusinessDay(mon)); // true
console.log(Weekday.isBusinessDay(sun)); // false
```


> The word in the streets: No usar enums, por qu√©?


## Typescript

## Intro
Superset de Js. Javascript es un lenguaje de tipado debil y din√°mico. Por tanto usamos TS para: ...
Ts es un linter, una herramienta de desarrollo. No trabaja en runtime si no en tiempo de compilado. Cuando nuestro c√≥digo se compila no queda ni rastro de TS (con alguna excepci√≥n que veremos m√°s adelante).

- Ts fue creado por Microsoft. Los mismos que crearon Vscode. Vscode code entiende Ts por defecto. Cuando tenemos un archivo abierto, nos indica los errores de ts sin que tengamos que instalar nada. Pero lo hace solo en los archivos que tenemos abiertos y relacionados. Por eso es aconsejable que corramos el compilador de tsc (`yarn tsc` o `npx tsc `) antes de abrir una PR y desde luego de integrar c√≥digo en develop. Eso lo podemos hacer en el paso del lint-staged. Next hace type checking cuando construye nuestro sitio.

- Extension typescript translator error

- Una funci√≥n puede estar correcta a nivel de valor, y no dar errores en runtime, pero tenemos errores. Est√° mal a nivel de tipos. Lo que Typescript est√° haciendo es asegurarse de que invoquemos como invoquemos a la funci√≥n, no vamos a tener errores de runtime. 

```ts
function addNumbers(a: number, b: number) {
	return a + b
}

// "correcto" a nivel de valores
// incorrecto a nivel de ts
addNumbers("1", 2) 
```


- Podemos usar Ts de una manera m√°s o menos valiosa. Porque typescript va a garantizar que podemos migrar de la manera m√°s simple posible, e ir tipando de manera incremental. Si somos m√°s espec√≠ficos, evitamos `any`s impl√≠citos y expl√≠citos, casting... tendremos una base de c√≥digo m√°s segura. Nos beneficiaremos m√°s de Typescript.


### Any
Any es un tipo peligroso. Nunca lo debemos usar expl√≠citamente y debemos evitar anys impl√≠citos, que se nos cuele un any en la base de c√≥digo. En ese sentido tenemos suerte porque usamos graphql y codegen y todo nos viene bien tipado de back. Pero por ejemplo puede pasar con servicios de terceros. O con librer√≠as externas.

Any tiende a ser infeccioso y extenderse por toda nuestra base de c√≥digo, con lo que perdemos la seguridad del type-checking. Estamos escribiendo TS para nada. 

```ts
function addNumbers(a: any, b: any) {
	return a + b
}

const result = addNumbers(1, 3) // any

// perdemos el autocomplete
result.toFixed()
```

> Podemos a√±adir `noImplicitAny: true`. Con `strict: true` ya prevenimos el uso de any explicito.


### Tipado de funciones
El tipado de nuestras variables y funciones es como la firma de un contrato que Typescript nos va a demandar de respetemos. 
Cuando escribimos funciones (o componentes, simplemente son funciones que devuelven JSX) es muy √∫til pensar en este contrato primero, y luego escribir una implementaci√≥n que cumpla este contrato. 

El tipado de funciones tiene dos partes, los par√°metros y el returned type, tipado de retorno. 


```ts
function parseMyData(data: Data): NormalizedData {}

const parseMyData = (data: Data): NormalizedData => {}

```

1. Anotaci√≥n de par√°metros
Es aconsejable pasar nuestros par√°metros todos dentro de un objeto, y tipar ese objeto. ¬øPor qu√©? Porque nos permite leer y debuguear las invocaciones a nuestra funci√≥n m√°s f√°cilmente. Tambi√©n escribirlas, porque no tenemos que mantener un orden espec√≠fico, ni tener en cuenta la opcionalidad de los par√°metros.

```ts
/** type function params */
function logMeals(breakfast: string, lunch?: string, dinner?: string) {
  return [breakfast, lunch, dinner]
}

logMeals("coffee", "pizza", "salad")
logMeals("coffee", undefined, "salad")

function logMealsObj(meals: {breakfast?: string, lunch?: string, dinner?: string}) {
  return meals
}

logMeals({breakfast: "hot cocoa" })

```

> Para ver las opciones de autocompletado podemos usar el comando: `ctrl + space bar`
> 
![[Screenshot 2023-03-05 at 11.06.01.png | 300]]

Formas en las que podemos ver tipados los par√°metros de una funci√≥n:

```ts

// tipos en linea

function myFunction({bar, foo, baz}: {bar: string, foo: string: baz: number}) {}

function myFunction(params: {bar: string, foo: string: baz: number}) {}

function myFunction({foo, ...rest}: {bar: string, foo: string: baz: number}) {}



// tipos extraidos

type Params = {bar: string, foo: string: baz: number}

function myFunction({bar, foo, baz}: Params) {}

```

> Una ventaja de trabajar con los tipos extra√≠dos es que la documentaci√≥n de Typescript va a ser menos verbosa. 
> 
> ![[Screenshot 2023-03-05 at 11.44.27.png | 600]]
> 
> ![[Screenshot 2023-03-05 at 11.44.35.png| 600]]


Cuando tenemos una funci√≥n que ya hemos creado con par√°metros fuera de un objeto y queremos a√±adir m√°s cosas sin tener que refactorizar o aumentar la interfaz de nuestra funci√≥n, una buena opci√≥n es crear una bolsa de par√°metros adicionales.

```ts

function myFunctionWithOptions(foo: string, bar: string, options?: {skip: boolean, ...}) {}

function myFunctionWithCallbacks(foo: string, bar: string, callbacks?: {onError: () => void, onSucess: () => void)}) {}

```

Par√°metros opcionales y valores por defecto:
```ts
function myFunction(foo: string, bar?: string) {} // optional params needs to go last

function myFunction(params: {foo?: string, bar: string}) {}

function myFunction(params: {foo: string = "Foo", bar: string}) {}
```

En mixins y en decoradores he visto que hacemos esto:
```ts
function myFunction(params: {foo?: string, bar?: string}) {} 

myFunction() // ‚ùå Expected 1 arguments, but got 0
myFunction({}) // ‚úÖ

function myFunction(params: {foo?: string, bar?: string} = {} ) {} // myFunction()
myFunction() // ‚úÖ
```

2. Tipos de retorno
Normalmente TS va a ser capaz de inferir muy bien nuestro tipo de retorno, pero en operaciones complicadas es √∫til hacerlo expl√≠cito para asegurar que nuestra funci√≥n devuelve lo que esperamos.

```ts
function addNumbers(a: number, b: number): number {
  return (a + b).toString() // Type 'string' is not assignable to type 'number'.
}
```

No es algo que haya visto usado habitualmente en el c√≥digo. Curiosamente s√≠ arrastramos de Plop el tipado de retorno de los componentes como `JSX.Element`, y recibimos errores cuando hacemos un early return que devuelve impl√≠citamente undefined.

Con esto, nos impedimos hacer algo que es perfectamente v√°lido y muchas veces no entendemos porqu√© tenemos ese error. Y entonces devolvemos un fragmento para contentar a TS. 
Esta bien si queremos que nuestras funciones devuelvan algo espec√≠fico, de lo que se trata con TS es de hacer las cosas con intencionalidad.

![[Screenshot 2023-03-05 at 11.10.52.png|400]]

**Arrow function vs Function declaration**

```ts

function myFunction(params: {bar: string, foo: string: baz: number}): number {}
const myFunction = (params: {bar: string, foo: string: baz: number}): number {}

```

**Function type**
Otra manera de tipar una funci√≥n, es crear un tipo aparte:

```ts
type MyFunction = (params: {a: string, b: string, options: {isAmazing: boolean, isOk: boolean}}) => void

// function as expresion
const myFunction: MyFunction = (params) => null // params will be typed
```


#### Function overloads
Es una t√©cnica m√°s avanzada en el uso de funciones con Typescript. Nos permite acumular diferentes tipos de contrato que pueden ser v√°lidos para una funci√≥n. La √∫ltima declaraci√≥n es la que contiene la implementaci√≥n final y debe ser lo suficientemente flexible como para englobar las declaraciones anteriores.

Es un buen recurso que explorar para cuando tenemos un componente que tiene la misma implementaci√≥n, pero cuya interfaz var√≠a.
- [Ejemplo](https://codesandbox.io/s/react-function-overloads-0b82yf?file=/src/ClassCard/ClassCardWithOverloads/index.tsx)

Recursos
- https://basarat.gitbook.io/typescript/type-system/functions#overloading
-  https://dmitripavlutin.com/typescript-function-overloading/


```jsx

// Upcoming class
export function ClassCard(props: {
	variant: 'card' | 'row';
	isUpcoming: true;
	onJoin?: (event: ChangeEvent) => void;
	onCancel?: () => void;
}): JSX.Element;

// Pass class
export function ClassCard(props: {
	variant: 'card' | 'row';
	isUpcoming?: false;
	onJoin?: never;
	onCancel?: never;
}): JSX.Element;


export function ClassCard(props: {
	variant: 'card' | 'row';
	isUpcoming?: boolean;
	onJoin?: (event: unknown) => void | never;
	onCancel?: unknown;
}) {
	// actual implementation
	// signature needs to be flexible enough to cover all previous declarations
}

// declarations needs to be just above function implementation

export function ClassCard(props: UpcomingClassProps): JSX.Element;
export function ClassCard(props: PastClassProps): JSX.Element;

export function ClassCard(props: Props) {
	// actual implementation
	// signature needs to be flexible enough to cover all previous declarations
}

// tambi√©n podemos declarar un tipo con todos los overloads

type StudentClassCardFunction = {
	(props: UpcomingClassProps): JSX.Element;
	(props: PastClassProps): JSX.Element;
};

export function ClassCard(props: Props) {
	// actual implementation
	// signature needs to be flexible enough to cover all previous declarations
} 
```


### Aserciones
- Interfaces vs Type
Las interfaces solo pueden definir objetos. Los tipos pueden ser cualquier cosa. A nivel de performance son equivalentes. Las interfaces est√°n m√°s enfocadas al uso de clases, pero podemos usar lo que prefiramos.

```ts
interface User {
	email: string;
	password: string
}

interface SuperUser extends User {
 isAdmin: true
}

class CreateUser implements User {}

```


- [ ] Que es eso de Record / Array. Constructos en Typescript
- [ ] Los tipos y las interfaces son "open-ended". Podemos pasar m√°s de lo que necesitamos, pero nunca menos. Ejemplo en replit

- As: type casting
Todos hemos usado `as` para hacer que Typescript se calle. Cuando usamos type casting estamos mintiendo al compilador de Typescript. Le estamos diciendo que nosotros sabemos m√°s que √©l, y eso no suele ser as√≠. 

Por ejemplo:

```ts
interface User {
	email: string;
	password: string
}

function getUserEmail(user: User) {
	return user.email
}

const user = {email: "thisisme@gmail.com"} as User

getUserEmail(user)
```


Un ejemplo en un componente de React, m√°s peligroso:

```ts
interface User {
	email: string;
	password: string
}

function MyComponent({user}: Props) {
	return <Card user={user as unknown as User}/>
}

<MyComponent user={...} />
```

Con `as` sobrescribimos el comportamiento natural del compilador. Este componente se puede invocar con los datos para user que al dev le parezca y hemos perdido toda seguridad, hemos escrito TS para nada y es probable que acabe arrojando errores en runtime que no vamos a poder detectar.


Es √∫til por ejemplo cuando estamos mockeando datos para nuestras stories de Storybook. En algunos casos no queremos tener que crear todo el objeto porque sabemos que solo vamos a usar alguna propiedad. Pero tarde o temprano refactorizamos y suele ser una manera de dispararnos en el pie. 

> total-typescript/mocks

- [ ] As vs Satifies

### Uniones vs Enums
En ocasiones necesitamos tipos m√°s precisos que los tipos primitivos, como number o string. El caso de uso habitual:

```ts
function logZ1Area(area: string) {
	console.log(`I work at the ${area} area of Z1`);
}

logZ1Area("Fantastic Beasts and Where to Find Them"); // ‚úÖ

type Area = "front-end" | "back-end" | "design";

function logZ1AreaNowForReal(area: Area) {
	console.log(`I work at the ${area} area of Z1`);
}

logZ1AreaNowForReal("back-end"); // ‚úÖ i get autocompletion of the possible options

```

Podemos hacer esto mismo con Enums. `enum` es un constructo de Typescript que usamos de forma muy frecuente, especialmente porque back-end nos trae muchos enums en los tipos del esquema de Graphql. 

Pero quiz√°s los enums no sean una gran idea despu√©s de todo. Muchos desarrolladores est√°n empezando a desaconsejar su uso. El propio equipo de Typescript ha manifestado que, de volver a empezar, es probable que no incluyeran enums en typescript: "Given a green field, it's not clear we would go there again." [ref](https://www.youtube.com/watch?v=vBJF0cJ_3G0). Veamos porqu√©: 

```ts
enum AreaEnum {
	FrontEnd = "front-end",
	Backend = "back-end",
	Design = "design",
}

function logZ1AreaWithEnums(area: AreaEnum) {
	console.log(`I work at the ${area} area of Z1`);
}

logZ1AreaWithEnums("front-end"); // ‚ùå Argument of type '"front-end"' is not assignable to parameter of type 'AreaEnum'
logZ1AreaWithEnums("front-end" as AreaEnum) // ‚ùå We'll be tempted of doing this
logZ1AreaWithEnums(AreaEnum.FrontEnd); // ‚úÖ
```

- La sintaxis es m√°s complicada. Si usamos enums impl√≠citos tenemos la sensaci√≥n de estar duplicando claves y valores
- Los number enums o enums impl√≠citos son peligrosos
```ts
enum AreaEnum {
	FrontEnd,
	Backend,
	Design,
}

console.log(AreaEnum.FrontEnd)
console.log(AreaEnum.Backend)

function isFrontEnd() {
	if(AreaEnum.FrontEnd) {
		return true // not getting here
	}
}

function isBackend() {
	if(AreaEnum.Backend === 1) {
		return true
	}
}

```
- Una vez que hemos declarado el enum, siempre tenemos que pasar un miembro del enum a nuestra funci√≥n. Para Typescript no es lo mismo "front-end" que  `AreaEnum.FrontEnd`, aunque sea su valor. Eso nos obliga a importar el enum en todos los archivos donde sea necesario, lo que aumenta la complejidad del c√≥digo y la carga cognitiva.
	- ¬øPorqu√© los enums funcionan as√≠? La ventaja que te ofrece vs el uso de uniones es que si tienes que cambiar el valor de un miembro del enum, lo haces en la declaraci√≥n y no tienes que renombrar en ning√∫n sitio m√°s. Pero es una ventaja que obtienes a cambio de usar una estructura mucho m√°s "pesada".
	- Una alternativa es usar objetos:

```ts
const Area = {
	frontEnd: "front-end",
	backEnd: "back-end",
	design: "design",
} as const

type Area = typeof Area[keyof typeof Area];

function logZ1AreaNowForReal(area: Area) {
	console.log(`I work at the ${area} area of Z1`);
}

logZ1AreaNowForReal("back-end"); // ‚úÖ i get autocompletion of the possible options

```

- Los enums s√≠ se compilan a Typescript. Son una feature runtime, aumentan el tama√±o de nuestro bundle (ejemplo de la funci√≥n que se genera: https://basarat.gitbook.io/typescript/type-system/enums#number-enums-and-strings)

- Los enums son un constructo propio de Typescript, aprender todas las maneras en que se comportan aumenta la carga cognitiva. En las uniones usamos strings, que son propios de Javascript. Estamos m√°s cerca de Javascript.

> Podemos a√±adir una propiedad a la configuraci√≥n de Graphql Codegen para que evite los enums:
> https://the-guild.dev/graphql/codegen/plugins/typescript/typescript#enumsastypes

Para generar uniones en lugar de enums:
```json
enumsAsTypes: true
```

Para generar const objects en lugar de enums:
```json
enumsAsConst: true
```


[Matt Pocock's Thread](https://twitter.com/mattpocockuk/status/1602975644245438464)
[Enums are terrible](https://www.youtube.com/watch?v=0fTdCSH_QEU)
[Why You Should Use String Literal Unions Over Enums in TypeScript](https://www.typescriptcourse.com/string-literal-unions-over-enums)


### Type intersections


### Generics
- [ ] https://www.digitalocean.com/community/tutorials/how-to-use-generics-in-typescript
Los gen√©ricos es un concepto avanzado de Typescript. Muchas veces pensamos que no los necesitamos, y la mayor√≠a de veces podemos pasar sin ellos. Pero si los conocemos, es un recurso que puede encajar para solucionar alg√∫n problema que se nos presente.

La principal motivaci√≥n para usar gen√©ricos es completar la informaci√≥n de tipos de una funci√≥n o componente no cuando la creamos si no en el momento en el que vamos a usarla. Los gen√©ricos son a los tipos como los par√°metros a las funciones. Nos permite crear comportamientos flexibles.

Un ejemplo que vemos constantemente es cuando usamos `useState`:

```tsx
const [list, setList] = useState<string[]>()

// gen√©rico inferido
const [list, setList] = useState(["lunes", "martes", "mi√©rcoles",...])

```

```tsx
function useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];
```

Los desarrolladores de React no pueden saber por adelantado el tipo de estado que queremos crear, as√≠ que han a√±adido un gen√©rico a `useState` para que nosotros podamos proveer esa informaci√≥n. Sin eso, list ser√≠a siempre `any`.

Otro es el de las queries de Apollo:

```tsx
type GetMeType = {
	teacher: {
		id: string;
		name: string;
	}
};

const {data} = useQuery<GetMeType>(
	gql`query getMe {
		me {
			id
			name
		}
	}`, 
);

data.id. // string
data.name // string

```

```tsx
export declare function useQuery<TData = any, TVariables = OperationVariables>(query: TypedDocumentNode<TData, TVariables>): QueryResult<TData, TVariables>;
```

```tsx
export interface QueryResult<TData = any, TVariables = OperationVariables> {
	data: TData | undefined;
	error?: ApolloError;
	loading: boolean;
	....
}
```

Los tipos de las librer√≠as siempre van a ser m√°s complicados que los tipos que usamos en una aplicaci√≥n. B√°sicamente porque el desarrollador de una librer√≠a tiene que anticiparse a diferentes casos de uso.

Pero, ¬øcu√°l puede ser un caso de uso interesante para nosotros de los gen√©ricos dentro de nuestras aplicaciones?


- El caso m√°s simple para demostrar los gen√©ricos es una identity function. ¬øC√≥mo hacemos para retornar el valor que pasamos a la funci√≥n tipado?

```tsx
function returnData(data: number) {
	return data;
}

function returnAnyTypesData(data: any) {
	return data;
}

function returnMoreTypesData(data: number | string | boolean) {
	return data;
}

function returnExactTypeData<T>(data: T) {
	return data;
}

const data1 = returnData(2); // number, not flexible
const data2 = returnAnyTypesData(2); // any, not type-safe
const data3 = returnMoreTypesData(2); // union, not my type
const data4a = returnExactTypeData(2); // number, exactly my type
const data4b = returnExactTypeData(true); // boolean, exactly my type
const data4c = returnExactTypeData(["americano", "latte", "mocha"]); // string[], exactly my type
```

- Ejemplo complejo de gen√©ricos en una funci√≥n:
https://www.youtube.com/watch?v=hBk4nV7q6-w&t=677s

```ts
export const getDeepValue = <
	T,
	TFirstKey extends keyof T,
	TSecondKey extends keyof T[TFirstKey]
>(
	obj: T,
	firstKey: TFirstKey,
	secondKey: TSecondKey
) => {
	return obj[firstKey][secondKey];
};

const obj = {
	foo: {
		a: true,
		b: 9398,
	},
	bar: {
		c: "hi!",
		d: [1, 2, 3],
	},
};

// val1 get to be typed correctly thanks to generics
const val1 = getDeepValue(obj, "foo", "a"); // boolean
const val2 = getDeepValue(obj, "bar", "c"); // string

// getDeepValue gets autocompletion and erroring for its params thanks to generics 
// ‚ùå Argument of type '"hi"' is not assignable to parameter of type '"a" | "b"'.
const val2 = getDeepValue(obj, "foo", "hi"); 

```

- En un custom hook:

```tsx
export function useLocalStorage<T>(key: string, defaultValue: T): T { 
	const [data, setData] = useState<T>(() => { 
		try { 
			const item = window.localStorage.getItem(key); 
			return item ? JSON.parse(item) : defaultValue; } 
		catch (error) { 
			return defaultValue; 
		} 
	}); 
		
	useEffect(() => { 
		try { 
			window.localStorage.setItem(key, JSON.stringify(data)); 
		} catch (error) { 
			console.warn(`Error storing data in localStorage: ${error.message}`); 
		} 
	}, [data, key]); 
		
	return data; 
}
```

- En un componente:

```tsx
type DropdownProps<T> {
  options: T[];
  onSelect: (selectedOption: T) => void;
}

function Dropdown<T>(props: DropdownProps<T>) {
  const [isOpen, setIsOpen] = useState(false);

  function handleSelect(selectedOption: T) {
    setIsOpen(false);
    props.onSelect(selectedOption);
  }

  return (
    <div>
      <button onClick={() => setIsOpen(!isOpen)}>
        Select an Option
      </button>
      {isOpen && (
        <ul>
          {props.options.map((option) => (
            <li key={option.toString()} onClick={() => handleSelect(option)}>
              {option}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

```tsx
<Dropdown options={["americano", "expresso", "machiato"]}/>
<Dropdown options={[10, 100, 1000]}/>
<Dropdown options={[true, false]}/>
```

En general, podemos usar gen√©ricos cuando queramos hacer una funci√≥n, custom hook o componente lo suficientemente flexible como para usarlo con diferentes tipos de datos. 


> Se suele decir que Typescript avanzando se usa solo en librer√≠as, pero eso no es completamente correcto. Se usa en abstracciones. Si queremos escribir una pieza de c√≥digo suficientemente abstracta en nuestra app, pero al mismo tiempo tiparla de manera segura, vamos a necesitar algunos recursos de Typescript avanzado.

> "When these generics and other advanced concepts really start to shine is when you're building code to write code" 
> ‚Äî Jason Lengstorf https://youtu.be/xk_PbxR7G8A?t=714

Cuando usamos TS tenemos autocomplete. No necesitamos mirar la declaraci√≥n del c√≥digo para usarlo.

Ejercicio 4 - paths object baselang

### Conditional types




- [ ] keyword never


- Total typescript Beginner
- Total typescript Tipz
- Total typescirpt Articles
- Typescript cours articles
- Typescript Deep dive
- FEM Mike North courses

- [ ] Utils + ts-reset


---
- Type annotations:
	- To function arguments
	- Tipos
		- Primitivos
		- Unions
		- Arrays
		- Objetos
			- Error https://www.totaltypescript.com/tutorials/beginners-typescript/assigning-dynamic-keys-to-an-object
			"Element of type x cannot be use to index type y". Cuando leas "index" en un error de TS, normalmente se est√° refiriendo a la key de un objeto 
		- ...
	- Narrow down union types. Necesitamos indicar a TS la rama de nuestra union por la que queremos ir.
	- Utils: Pick, Omit (Ale), nuestros propios utils, donde los ponemos: globals/types/utils
	- trabajar con codegen 
		- Combinar y construir tipos selectivamente
		- Indexar, mapear y usae returnedtype

> Cuando usamos TS necesitamos pensar donde queremos generar un contrato entre los tipos y los valores. As√≠ recibir√© los errores en el contexto adecuado y adem√°s me beneficio del autocompletado.
> https://www.totaltypescript.com/tutorials/beginners-typescript/assigning-types-to-variables/solution


### Handbook notes

**Basic info**
Javascript interpreta los tipos de los valores en runtime, es tipado din√°mico (JS interpreta el tipo de nuestro valor en runtime para saber qu√© comportamientos son los correctos). Typescript a√±ade tipado est√°tico a Javascript.Un sistema de tipado est√°tico describe las formas y comportamientos de los valores que tendremos cuando nuestros c√≥digo se ejecute (en runtime).

Con JS no sabemos qu√© va a pasar con nuestro c√≥digo hasta que no lo ejecutamos y ya es demasiado tarde:

```
message.toLowerCase()
message()
```

-  TS detecta errores y bugs en el c√≥digo que no encontrar√≠amos en JS (object.property -> undefined)
- TS nos ayuda a no tener qu√© "recordar" el tipo de datos de nuestras variables. Reducimos carga cognitiva 
- Pero tambi√©n puede prevenirlos gracias a su experiencia de edici√≥n con autocompletado y errores (tooling en ts).

TS toma decisiones acerca de qu√© es un error en el sistema. Por ejemplo, en Javascript cuando trabajos de acceder una propiedad que no existe en un objeto, no se retorna un error, si no undefined. TS nos advierte con un error. Eso hace que nos resulte a veces molesto, pero el objetivo es evitar bugs en runtime. Otras cosas de las que nos advierte son tipos, funciones sin invocar o errores de l√≥gica.

Adem√°s de cazar bugs, al proporcionar informaci√≥n sobre nuestros valores a TS, TS conoce lo suficiente de nuestro c√≥digo para darnos opciones de autocompletado. Los mensajes de error y el autocompletado que TS nos aporta al editar c√≥digo se conocen como el "tooling" de TS. Tambi√©n incluye quick fixes, shortcuts de navegacion, b√∫squeda, etc.

**TSC**
TSC es el compilador de TS, nuestro type-checker. Cuando corremos el comando va tomar nuestros archivos ts y emitir archivos js, a no ser que especifiquemos lo contrario. TS trata de emitir c√≥digo legible, formateado, que una persona podr√≠a escribir. Si no encuentra errores, emitir√° el archivo correctamente, si los encuentra, los sacar√° por la terminal y tambi√©n emitir√° el archivo, para no interponerse en nuestro camino en caso de que pro ejemplo, estemos migrando nuestro javascript funcional a TS.
Podemos configurar nuestro TSC para ser m√°s defensivo, por ejemplo usando la bandera `--noEmitOnError`


**Tipos explicitos o anotaciones**
Con las anotaciones describimos los tipos de nuestros valores. Aunque no siempre son necesarias, muchas veces TS es capaz de inferir los tipos en base a los valores.


---
INTERESTING TYPESCRIPT PROBLEM 

```TS

// eslint-disable-next-line @typescript-eslint/no-explicit-any

export const getObjValues = <T extends Record<string, unknown>>(

obj: T,

properties = [],

) => {

if (typeof obj === 'object') {

Object.values(obj).forEach((primitiveOrObject) => {

if (typeof primitiveOrObject === 'object' && primitiveOrObject !== null) {

getObjValues(primitiveOrObject as Record<string, unknown>, properties);

}

});

} else {

properties.push(obj);

}

  

return properties;

};

  

// expect(

// getObjValues({

// label: 'hello',

// numbers: {

// first: 1,

// second: 2,

// },

// }),

// ).toEqual(['hello', 1, 2]);
```
