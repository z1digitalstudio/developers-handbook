# Typescript tips

---
- 🇪🇸 Idioma: Español
- 😸 Autores: María Simó
- 🗓️ Creado: 03/03/2023

---

Recursos:
https://www.typescriptcourse.com/articles
https://basarat.gitbook.io/typescript/
https://www.totaltypescript.com
TS Crash course: https://www.youtube.com/watch?v=p6dO9u0M7MQ
TS Tips and tricks (advanced): https://www.youtube.com/watch?v=hBk4nV7q6-w

matt pococks on youtube - learn w jason

Tools: 
- https://github.com/millsp/ts-toolbelt
- total typescript reset


Guia nueva
- npmp
- apollo codegen
- next 13
- testing setup


## TL;DR
- Problemas comunes de Typescript que podemos encontrar en nuestros proyectos
- Recomendación typescript-reset y typescript-utils
- Visibilidad que problemas solucionamos
- Recursos


- Unions
- Narrowing
- Type predicates
- Como tipar un reduces
- As y satisdies
- Any
- Returned types
- Genéricos
- Function signature
- Tipos condicionales
- Utils de typescript


- Montar escenarios de Typescript: Recetario
- As
- Any
- Tipar un reduce
- Genérico
- Preguntar a los compis
- Returned types
- Tipar una función
- Type predicates
- Discriminar uniones
- Tipos condicionales
- https://www.benmvp.com/blog/filtering-undefined-elements-from-array-typescript/
- Clases de matt



Publicar en dev, poner por twitter y decir que también lo he subido al blog



## Type transformation
- keyof
- unions to arrays and objects
- enums to arrays and objects
- object to union
- unions vs enums


### types from types
https://www.typescriptlang.org/docs/handbook/2/types-from-types.html


- typeof https://www.typescriptlang.org/docs/handbook/2/typeof-types.html
- keyof https://www.typescriptlang.org/docs/handbook/2/keyof-types.html
- utility types https://www.typescriptlang.org/docs/handbook/utility-types.html (custom)
- typing promises https://www.totaltypescript.com/tutorials/beginners-typescript/typing-promises-and-async-requests
- unions https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types
- discriminate unions
- as const
- indexed access types
- template literal types https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html
- mapped types https://www.typescriptlang.org/docs/handbook/2/mapped-types.html
- discriminated unions https://basarat.gitbook.io/typescript/type-system/discriminated-unions
- template literal types https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html
- generics https://www.totaltypescript.com/mental-model-for-typescript-generics


Typescript es un superset de Javascript. Es un añadido. Es una herramienta de desarrollo. Nuestro código final, que pongamos en producción, nunca va a ser typescript, se va a compilar javascript. Usamos Ts durante la fase de desarrollo para aportar robustez a nuestro código, detectar errores, tener autocompletado, alinearnos con la API tipada que recibimos de back, porque GraphQL es una especificación esencialmente tipada.

TS añade "tipos" a JS. ¿Qué son los tipos?
- Son anotaciones que añadimos al código para declarar de qué tipo son nuestros datos.
- Javascript es un lenguaje de tipado débil y dinámico
- Aumentan nuestra velocidad en el refactoring, nos ayudan a cazar errores en runtime
- Son una buena forma de documentación. Una de las mejores formas de saber lo que una función hace (tmabien de escribirla) es tener tipado su input y su output: "The function signature is the theorem and the function body is the proof"
- TypeScript is just JavaScript with docs.
- Es un linter con información de tipos

![[Screenshot 2023-03-04 at 09.41.14.png|300]]


### Adopción de TS y niveles de uso
Moverse a TS es más fácil de lo que parece por dos razones:
- Sigue siendo Javascript
- Tiene una adopción incremental (aceptar any de forma implícita o explícita)
- Tipos implícitos e inferidos


Esta es la razón por la que muchos convivimos con Ts en nuestro desarrollo diario en diferentes grados, sabiendo más o menos como funciona. Trabajando con él o alrededor de él. 

Typescript es muy flexible, su prioridad va a ser que podamos trabajar de la manera más fácil y segura con Javascript. El nos va a devolver en seguridad y auto-completado tanto como nosotros le demos. 

- Tipos explícitos:
En muchas ocasiones podemos confiar en la inferencia de tipos de TS. En otras queremos ser explícitos, para asegurarnos un determinado tipo en nuestros datos, ser intencionales, documentar.

La manera más sencilla de tipar es usar una anotación de este tipo:

```
let name: string = "Greta"

name = 2 // Error: cannot assign a `number` to a `string`
```

- Tipos estructurales
Los tipos de TS son estructurales, para reducir la carga cognitiva que supone TS al máximo. 
Una función/componente va a aceptar cualquier tipo que cumpla el contrato, aunque el valor que pasemos tenga propiedades adicionales. Nunca puede tener de menos, pero sí demás.

### Ts type system

- Enum. Colección de valores relacionados. 
	- Number enums, cuando no asignamos un valor a los miembros del enum
```
enum Z1 {
  Product,
	Design,
	Backend,
	Frontend,
}


const area1: Z1 = 0 // valid
const area2: Z1 = Z1.Product // valid
console.log(area1 === area2) // true
```

- Mas tipos:
	- String enums
	- Cons enums, pueden suponer un boost de performance, porque no se compilan en runtime
	
```
const enum Options {
	False
	True
	Unknown
}

const isTrue = Options.False

// compirala a 
const isTrue = 0
```

El valor del miembro del enum se calcula en línea y no se genera Javascript para el enum.

Añadir un método al enum:
```
enum Weekday {
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
}
namespace Weekday {
    export function isBusinessDay(day: Weekday) {
        switch (day) {
            case Weekday.Saturday:
            case Weekday.Sunday:
                return false;
            default:
                return true;
        }
    }
}

const mon = Weekday.Monday;
const sun = Weekday.Sunday;
console.log(Weekday.isBusinessDay(mon)); // true
console.log(Weekday.isBusinessDay(sun)); // false
```


> The word in the streets: No usar enums, por qué?


## Typescript

## Intro
Superset de Js. Javascript es un lenguaje de tipado debil y dinámico. Por tanto usamos TS para: ...
Ts es un linter, una herramienta de desarrollo. No trabaja en runtime si no en tiempo de compilado. Cuando nuestro código se compila no queda ni rastro de TS (con alguna excepción que veremos más adelante).

- Ts fue creado por Microsoft. Los mismos que crearon Vscode. Vscode code entiende Ts por defecto. Cuando tenemos un archivo abierto, nos indica los errores de ts sin que tengamos que instalar nada. Pero lo hace solo en los archivos que tenemos abiertos y relacionados. Por eso es aconsejable que corramos el compilador de tsc (`yarn tsc` o `npx tsc `) antes de abrir una PR y desde luego de integrar código en develop. Eso lo podemos hacer en el paso del lint-staged. Next hace type checking cuando construye nuestro sitio.

- Extension typescript translator error

- Una función puede estar correcta a nivel de valor, y no dar errores en runtime, pero tenemos errores. Está mal a nivel de tipos. Lo que Typescript está haciendo es asegurarse de que invoquemos como invoquemos a la función, no vamos a tener errores de runtime. 

```ts
function addNumbers(a: number, b: number) {
	return a + b
}

// "correcto" a nivel de valores
// incorrecto a nivel de ts
addNumbers("1", 2) 
```


- Podemos usar Ts de una manera más o menos valiosa. Porque typescript va a garantizar que podemos migrar de la manera más simple posible, e ir tipando de manera incremental. Si somos más específicos, evitamos `any`s implícitos y explícitos, casting... tendremos una base de código más segura. Nos beneficiaremos más de Typescript.


### Any
Any es un tipo peligroso. Nunca lo debemos usar explícitamente y debemos evitar anys implícitos, que se nos cuele un any en la base de código. En ese sentido tenemos suerte porque usamos graphql y codegen y todo nos viene bien tipado de back. Pero por ejemplo puede pasar con servicios de terceros. O con librerías externas.

Any tiende a ser infeccioso y extenderse por toda nuestra base de código, con lo que perdemos la seguridad del type-checking. Estamos escribiendo TS para nada. 

```ts
function addNumbers(a: any, b: any) {
	return a + b
}

const result = addNumbers(1, 3) // any

// perdemos el autocomplete
result.toFixed()
```

> Podemos añadir `noImplicitAny: true`. Con `strict: true` ya prevenimos el uso de any explicito.


### Tipado de funciones
El tipado de nuestras variables y funciones es como la firma de un contrato que Typescript nos va a demandar de respetemos. 
Cuando escribimos funciones (o componentes, simplemente son funciones que devuelven JSX) es muy útil pensar en este contrato primero, y luego escribir una implementación que cumpla este contrato. 

El tipado de funciones tiene dos partes, los parámetros y el returned type, tipado de retorno. 


```ts
function parseMyData(data: Data): NormalizedData {}

const parseMyData = (data: Data): NormalizedData => {}

```

1. Anotación de parámetros
Es aconsejable pasar nuestros parámetros todos dentro de un objeto, y tipar ese objeto. ¿Por qué? Porque nos permite leer y debuguear las invocaciones a nuestra función más fácilmente. También escribirlas, porque no tenemos que mantener un orden específico, ni tener en cuenta la opcionalidad de los parámetros.

```ts
/** type function params */
function logMeals(breakfast: string, lunch?: string, dinner?: string) {
  return [breakfast, lunch, dinner]
}

logMeals("coffee", "pizza", "salad")
logMeals("coffee", undefined, "salad")

function logMealsObj(meals: {breakfast?: string, lunch?: string, dinner?: string}) {
  return meals
}

logMeals({breakfast: "hot cocoa" })

```

> Para ver las opciones de autocompletado podemos usar el comando: `ctrl + space bar`
> 
![[Screenshot 2023-03-05 at 11.06.01.png | 300]]

Formas en las que podemos ver tipados los parámetros de una función:

```ts

// tipos en linea

function myFunction({bar, foo, baz}: {bar: string, foo: string: baz: number}) {}

function myFunction(params: {bar: string, foo: string: baz: number}) {}

function myFunction({foo, ...rest}: {bar: string, foo: string: baz: number}) {}



// tipos extraidos

type Params = {bar: string, foo: string: baz: number}

function myFunction({bar, foo, baz}: Params) {}

```

> Una ventaja de trabajar con los tipos extraídos es que la documentación de Typescript va a ser menos verbosa. 
> 
> ![[Screenshot 2023-03-05 at 11.44.27.png | 600]]
> 
> ![[Screenshot 2023-03-05 at 11.44.35.png| 600]]


Cuando tenemos una función que ya hemos creado con parámetros fuera de un objeto y queremos añadir más cosas sin tener que refactorizar o aumentar la interfaz de nuestra función, una buena opción es crear una bolsa de parámetros adicionales.

```ts

function myFunctionWithOptions(foo: string, bar: string, options?: {skip: boolean, ...}) {}

function myFunctionWithCallbacks(foo: string, bar: string, callbacks?: {onError: () => void, onSucess: () => void)}) {}

```

Parámetros opcionales y valores por defecto:
```ts
function myFunction(foo: string, bar?: string) {} // optional params needs to go last

function myFunction(params: {foo?: string, bar: string}) {}

function myFunction(params: {foo: string = "Foo", bar: string}) {}
```

En mixins y en decoradores he visto que hacemos esto:
```ts
function myFunction(params: {foo?: string, bar?: string}) {} 

myFunction() // ❌ Expected 1 arguments, but got 0
myFunction({}) // ✅

function myFunction(params: {foo?: string, bar?: string} = {} ) {} // myFunction()
myFunction() // ✅
```

2. Tipos de retorno
Normalmente TS va a ser capaz de inferir muy bien nuestro tipo de retorno, pero en operaciones complicadas es útil hacerlo explícito para asegurar que nuestra función devuelve lo que esperamos.

```ts
function addNumbers(a: number, b: number): number {
  return (a + b).toString() // Type 'string' is not assignable to type 'number'.
}
```

No es algo que haya visto usado habitualmente en el código. Curiosamente sí arrastramos de Plop el tipado de retorno de los componentes como `JSX.Element`, y recibimos errores cuando hacemos un early return que devuelve implícitamente undefined.

Con esto, nos impedimos hacer algo que es perfectamente válido y muchas veces no entendemos porqué tenemos ese error. Y entonces devolvemos un fragmento para contentar a TS. 
Esta bien si queremos que nuestras funciones devuelvan algo específico, de lo que se trata con TS es de hacer las cosas con intencionalidad.

![[Screenshot 2023-03-05 at 11.10.52.png|400]]

**Arrow function vs Function declaration**

```ts

function myFunction(params: {bar: string, foo: string: baz: number}): number {}
const myFunction = (params: {bar: string, foo: string: baz: number}): number {}

```

**Function type**
Otra manera de tipar una función, es crear un tipo aparte:

```ts
type MyFunction = (params: {a: string, b: string, options: {isAmazing: boolean, isOk: boolean}}) => void

// function as expresion
const myFunction: MyFunction = (params) => null // params will be typed
```


#### Function overloads
Es una técnica más avanzada en el uso de funciones con Typescript. Nos permite acumular diferentes tipos de contrato que pueden ser válidos para una función. La última declaración es la que contiene la implementación final y debe ser lo suficientemente flexible como para englobar las declaraciones anteriores.

Es un buen recurso que explorar para cuando tenemos un componente que tiene la misma implementación, pero cuya interfaz varía.
- [Ejemplo](https://codesandbox.io/s/react-function-overloads-0b82yf?file=/src/ClassCard/ClassCardWithOverloads/index.tsx)

Recursos
- https://basarat.gitbook.io/typescript/type-system/functions#overloading
-  https://dmitripavlutin.com/typescript-function-overloading/


```jsx

// Upcoming class
export function ClassCard(props: {
	variant: 'card' | 'row';
	isUpcoming: true;
	onJoin?: (event: ChangeEvent) => void;
	onCancel?: () => void;
}): JSX.Element;

// Pass class
export function ClassCard(props: {
	variant: 'card' | 'row';
	isUpcoming?: false;
	onJoin?: never;
	onCancel?: never;
}): JSX.Element;


export function ClassCard(props: {
	variant: 'card' | 'row';
	isUpcoming?: boolean;
	onJoin?: (event: unknown) => void | never;
	onCancel?: unknown;
}) {
	// actual implementation
	// signature needs to be flexible enough to cover all previous declarations
}

// declarations needs to be just above function implementation

export function ClassCard(props: UpcomingClassProps): JSX.Element;
export function ClassCard(props: PastClassProps): JSX.Element;

export function ClassCard(props: Props) {
	// actual implementation
	// signature needs to be flexible enough to cover all previous declarations
}

// también podemos declarar un tipo con todos los overloads

type StudentClassCardFunction = {
	(props: UpcomingClassProps): JSX.Element;
	(props: PastClassProps): JSX.Element;
};

export function ClassCard(props: Props) {
	// actual implementation
	// signature needs to be flexible enough to cover all previous declarations
} 
```


### Aserciones
- Interfaces vs Type
Las interfaces solo pueden definir objetos. Los tipos pueden ser cualquier cosa. A nivel de performance son equivalentes. Las interfaces están más enfocadas al uso de clases, pero podemos usar lo que prefiramos.

```ts
interface User {
	email: string;
	password: string
}

interface SuperUser extends User {
 isAdmin: true
}

class CreateUser implements User {}

```


- [ ] Que es eso de Record / Array. Constructos en Typescript
- [ ] Los tipos y las interfaces son "open-ended". Podemos pasar más de lo que necesitamos, pero nunca menos. Ejemplo en replit

- As: type casting
Todos hemos usado `as` para hacer que Typescript se calle. Cuando usamos type casting estamos mintiendo al compilador de Typescript. Le estamos diciendo que nosotros sabemos más que él, y eso no suele ser así. 

Por ejemplo:

```ts
interface User {
	email: string;
	password: string
}

function getUserEmail(user: User) {
	return user.email
}

const user = {email: "thisisme@gmail.com"} as User

getUserEmail(user)
```


Un ejemplo en un componente de React, más peligroso:

```ts
interface User {
	email: string;
	password: string
}

function MyComponent({user}: Props) {
	return <Card user={user as unknown as User}/>
}

<MyComponent user={...} />
```

Con `as` sobrescribimos el comportamiento natural del compilador. Este componente se puede invocar con los datos para user que al dev le parezca y hemos perdido toda seguridad, hemos escrito TS para nada y es probable que acabe arrojando errores en runtime que no vamos a poder detectar.


Es útil por ejemplo cuando estamos mockeando datos para nuestras stories de Storybook. En algunos casos no queremos tener que crear todo el objeto porque sabemos que solo vamos a usar alguna propiedad. Pero tarde o temprano refactorizamos y suele ser una manera de dispararnos en el pie. 

> total-typescript/mocks

- [ ] As vs Satifies

### Uniones vs Enums
En ocasiones necesitamos tipos más precisos que los tipos primitivos, como number o string. El caso de uso habitual:

```ts
function logZ1Area(area: string) {
	console.log(`I work at the ${area} area of Z1`);
}

logZ1Area("Fantastic Beasts and Where to Find Them"); // ✅

type Area = "front-end" | "back-end" | "design";

function logZ1AreaNowForReal(area: Area) {
	console.log(`I work at the ${area} area of Z1`);
}

logZ1AreaNowForReal("back-end"); // ✅ i get autocompletion of the possible options

```

Podemos hacer esto mismo con Enums. `enum` es un constructo de Typescript que usamos de forma muy frecuente, especialmente porque back-end nos trae muchos enums en los tipos del esquema de Graphql. 

Pero quizás los enums no sean una gran idea después de todo. Muchos desarrolladores están empezando a desaconsejar su uso. El propio equipo de Typescript ha manifestado que, de volver a empezar, es probable que no incluyeran enums en typescript: "Given a green field, it's not clear we would go there again." [ref](https://www.youtube.com/watch?v=vBJF0cJ_3G0). Veamos porqué: 

```ts
enum AreaEnum {
	FrontEnd = "front-end",
	Backend = "back-end",
	Design = "design",
}

function logZ1AreaWithEnums(area: AreaEnum) {
	console.log(`I work at the ${area} area of Z1`);
}

logZ1AreaWithEnums("front-end"); // ❌ Argument of type '"front-end"' is not assignable to parameter of type 'AreaEnum'
logZ1AreaWithEnums("front-end" as AreaEnum) // ❌ We'll be tempted of doing this
logZ1AreaWithEnums(AreaEnum.FrontEnd); // ✅
```

- La sintaxis es más complicada. Si usamos enums implícitos tenemos la sensación de estar duplicando claves y valores
- Los number enums o enums implícitos son peligrosos
```ts
enum AreaEnum {
	FrontEnd,
	Backend,
	Design,
}

console.log(AreaEnum.FrontEnd)
console.log(AreaEnum.Backend)

function isFrontEnd() {
	if(AreaEnum.FrontEnd) {
		return true // not getting here
	}
}

function isBackend() {
	if(AreaEnum.Backend === 1) {
		return true
	}
}

```
- Una vez que hemos declarado el enum, siempre tenemos que pasar un miembro del enum a nuestra función. Para Typescript no es lo mismo "front-end" que  `AreaEnum.FrontEnd`, aunque sea su valor. Eso nos obliga a importar el enum en todos los archivos donde sea necesario, lo que aumenta la complejidad del código y la carga cognitiva.
	- ¿Porqué los enums funcionan así? La ventaja que te ofrece vs el uso de uniones es que si tienes que cambiar el valor de un miembro del enum, lo haces en la declaración y no tienes que renombrar en ningún sitio más. Pero es una ventaja que obtienes a cambio de usar una estructura mucho más "pesada".
	- Una alternativa es usar objetos:

```ts
const Area = {
	frontEnd: "front-end",
	backEnd: "back-end",
	design: "design",
} as const

type Area = typeof Area[keyof typeof Area];

function logZ1AreaNowForReal(area: Area) {
	console.log(`I work at the ${area} area of Z1`);
}

logZ1AreaNowForReal("back-end"); // ✅ i get autocompletion of the possible options

```

- Los enums sí se compilan a Typescript. Son una feature runtime, aumentan el tamaño de nuestro bundle (ejemplo de la función que se genera: https://basarat.gitbook.io/typescript/type-system/enums#number-enums-and-strings)

- Los enums son un constructo propio de Typescript, aprender todas las maneras en que se comportan aumenta la carga cognitiva. En las uniones usamos strings, que son propios de Javascript. Estamos más cerca de Javascript.

> Podemos añadir una propiedad a la configuración de Graphql Codegen para que evite los enums:
> https://the-guild.dev/graphql/codegen/plugins/typescript/typescript#enumsastypes

Para generar uniones en lugar de enums:
```json
enumsAsTypes: true
```

Para generar const objects en lugar de enums:
```json
enumsAsConst: true
```


[Matt Pocock's Thread](https://twitter.com/mattpocockuk/status/1602975644245438464)
[Enums are terrible](https://www.youtube.com/watch?v=0fTdCSH_QEU)
[Why You Should Use String Literal Unions Over Enums in TypeScript](https://www.typescriptcourse.com/string-literal-unions-over-enums)


### Type intersections


### Generics
- [ ] https://www.digitalocean.com/community/tutorials/how-to-use-generics-in-typescript
Los genéricos es un concepto avanzado de Typescript. Muchas veces pensamos que no los necesitamos, y la mayoría de veces podemos pasar sin ellos. Pero si los conocemos, es un recurso que puede encajar para solucionar algún problema que se nos presente.

La principal motivación para usar genéricos es completar la información de tipos de una función o componente no cuando la creamos si no en el momento en el que vamos a usarla. Los genéricos son a los tipos como los parámetros a las funciones. Nos permite crear comportamientos flexibles.

Un ejemplo que vemos constantemente es cuando usamos `useState`:

```tsx
const [list, setList] = useState<string[]>()

// genérico inferido
const [list, setList] = useState(["lunes", "martes", "miércoles",...])

```

```tsx
function useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];
```

Los desarrolladores de React no pueden saber por adelantado el tipo de estado que queremos crear, así que han añadido un genérico a `useState` para que nosotros podamos proveer esa información. Sin eso, list sería siempre `any`.

Otro es el de las queries de Apollo:

```tsx
type GetMeType = {
	teacher: {
		id: string;
		name: string;
	}
};

const {data} = useQuery<GetMeType>(
	gql`query getMe {
		me {
			id
			name
		}
	}`, 
);

data.id. // string
data.name // string

```

```tsx
export declare function useQuery<TData = any, TVariables = OperationVariables>(query: TypedDocumentNode<TData, TVariables>): QueryResult<TData, TVariables>;
```

```tsx
export interface QueryResult<TData = any, TVariables = OperationVariables> {
	data: TData | undefined;
	error?: ApolloError;
	loading: boolean;
	....
}
```

Los tipos de las librerías siempre van a ser más complicados que los tipos que usamos en una aplicación. Básicamente porque el desarrollador de una librería tiene que anticiparse a diferentes casos de uso.

Pero, ¿cuál puede ser un caso de uso interesante para nosotros de los genéricos dentro de nuestras aplicaciones?


- El caso más simple para demostrar los genéricos es una identity function. ¿Cómo hacemos para retornar el valor que pasamos a la función tipado?

```tsx
function returnData(data: number) {
	return data;
}

function returnAnyTypesData(data: any) {
	return data;
}

function returnMoreTypesData(data: number | string | boolean) {
	return data;
}

function returnExactTypeData<T>(data: T) {
	return data;
}

const data1 = returnData(2); // number, not flexible
const data2 = returnAnyTypesData(2); // any, not type-safe
const data3 = returnMoreTypesData(2); // union, not my type
const data4a = returnExactTypeData(2); // number, exactly my type
const data4b = returnExactTypeData(true); // boolean, exactly my type
const data4c = returnExactTypeData(["americano", "latte", "mocha"]); // string[], exactly my type
```

- Ejemplo complejo de genéricos en una función:
https://www.youtube.com/watch?v=hBk4nV7q6-w&t=677s

```ts
export const getDeepValue = <
	T,
	TFirstKey extends keyof T,
	TSecondKey extends keyof T[TFirstKey]
>(
	obj: T,
	firstKey: TFirstKey,
	secondKey: TSecondKey
) => {
	return obj[firstKey][secondKey];
};

const obj = {
	foo: {
		a: true,
		b: 9398,
	},
	bar: {
		c: "hi!",
		d: [1, 2, 3],
	},
};

// val1 get to be typed correctly thanks to generics
const val1 = getDeepValue(obj, "foo", "a"); // boolean
const val2 = getDeepValue(obj, "bar", "c"); // string

// getDeepValue gets autocompletion and erroring for its params thanks to generics 
// ❌ Argument of type '"hi"' is not assignable to parameter of type '"a" | "b"'.
const val2 = getDeepValue(obj, "foo", "hi"); 

```

- En un custom hook:

```tsx
export function useLocalStorage<T>(key: string, defaultValue: T): T { 
	const [data, setData] = useState<T>(() => { 
		try { 
			const item = window.localStorage.getItem(key); 
			return item ? JSON.parse(item) : defaultValue; } 
		catch (error) { 
			return defaultValue; 
		} 
	}); 
		
	useEffect(() => { 
		try { 
			window.localStorage.setItem(key, JSON.stringify(data)); 
		} catch (error) { 
			console.warn(`Error storing data in localStorage: ${error.message}`); 
		} 
	}, [data, key]); 
		
	return data; 
}
```

- En un componente:

```tsx
type DropdownProps<T> {
  options: T[];
  onSelect: (selectedOption: T) => void;
}

function Dropdown<T>(props: DropdownProps<T>) {
  const [isOpen, setIsOpen] = useState(false);

  function handleSelect(selectedOption: T) {
    setIsOpen(false);
    props.onSelect(selectedOption);
  }

  return (
    <div>
      <button onClick={() => setIsOpen(!isOpen)}>
        Select an Option
      </button>
      {isOpen && (
        <ul>
          {props.options.map((option) => (
            <li key={option.toString()} onClick={() => handleSelect(option)}>
              {option}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

```tsx
<Dropdown options={["americano", "expresso", "machiato"]}/>
<Dropdown options={[10, 100, 1000]}/>
<Dropdown options={[true, false]}/>
```

En general, podemos usar genéricos cuando queramos hacer una función, custom hook o componente lo suficientemente flexible como para usarlo con diferentes tipos de datos. 


> Se suele decir que Typescript avanzando se usa solo en librerías, pero eso no es completamente correcto. Se usa en abstracciones. Si queremos escribir una pieza de código suficientemente abstracta en nuestra app, pero al mismo tiempo tiparla de manera segura, vamos a necesitar algunos recursos de Typescript avanzado.

> "When these generics and other advanced concepts really start to shine is when you're building code to write code" 
> — Jason Lengstorf https://youtu.be/xk_PbxR7G8A?t=714

Cuando usamos TS tenemos autocomplete. No necesitamos mirar la declaración del código para usarlo.

Ejercicio 4 - paths object baselang

### Conditional types




- [ ] keyword never


- Total typescript Beginner
- Total typescript Tipz
- Total typescirpt Articles
- Typescript cours articles
- Typescript Deep dive
- FEM Mike North courses

- [ ] Utils + ts-reset


---
- Type annotations:
	- To function arguments
	- Tipos
		- Primitivos
		- Unions
		- Arrays
		- Objetos
			- Error https://www.totaltypescript.com/tutorials/beginners-typescript/assigning-dynamic-keys-to-an-object
			"Element of type x cannot be use to index type y". Cuando leas "index" en un error de TS, normalmente se está refiriendo a la key de un objeto 
		- ...
	- Narrow down union types. Necesitamos indicar a TS la rama de nuestra union por la que queremos ir.
	- Utils: Pick, Omit (Ale), nuestros propios utils, donde los ponemos: globals/types/utils
	- trabajar con codegen 
		- Combinar y construir tipos selectivamente
		- Indexar, mapear y usae returnedtype

> Cuando usamos TS necesitamos pensar donde queremos generar un contrato entre los tipos y los valores. Así recibiré los errores en el contexto adecuado y además me beneficio del autocompletado.
> https://www.totaltypescript.com/tutorials/beginners-typescript/assigning-types-to-variables/solution


### Handbook notes

**Basic info**
Javascript interpreta los tipos de los valores en runtime, es tipado dinámico (JS interpreta el tipo de nuestro valor en runtime para saber qué comportamientos son los correctos). Typescript añade tipado estático a Javascript.Un sistema de tipado estático describe las formas y comportamientos de los valores que tendremos cuando nuestros código se ejecute (en runtime).

Con JS no sabemos qué va a pasar con nuestro código hasta que no lo ejecutamos y ya es demasiado tarde:

```
message.toLowerCase()
message()
```

-  TS detecta errores y bugs en el código que no encontraríamos en JS (object.property -> undefined)
- TS nos ayuda a no tener qué "recordar" el tipo de datos de nuestras variables. Reducimos carga cognitiva 
- Pero también puede prevenirlos gracias a su experiencia de edición con autocompletado y errores (tooling en ts).

TS toma decisiones acerca de qué es un error en el sistema. Por ejemplo, en Javascript cuando trabajos de acceder una propiedad que no existe en un objeto, no se retorna un error, si no undefined. TS nos advierte con un error. Eso hace que nos resulte a veces molesto, pero el objetivo es evitar bugs en runtime. Otras cosas de las que nos advierte son tipos, funciones sin invocar o errores de lógica.

Además de cazar bugs, al proporcionar información sobre nuestros valores a TS, TS conoce lo suficiente de nuestro código para darnos opciones de autocompletado. Los mensajes de error y el autocompletado que TS nos aporta al editar código se conocen como el "tooling" de TS. También incluye quick fixes, shortcuts de navegacion, búsqueda, etc.

**TSC**
TSC es el compilador de TS, nuestro type-checker. Cuando corremos el comando va tomar nuestros archivos ts y emitir archivos js, a no ser que especifiquemos lo contrario. TS trata de emitir código legible, formateado, que una persona podría escribir. Si no encuentra errores, emitirá el archivo correctamente, si los encuentra, los sacará por la terminal y también emitirá el archivo, para no interponerse en nuestro camino en caso de que pro ejemplo, estemos migrando nuestro javascript funcional a TS.
Podemos configurar nuestro TSC para ser más defensivo, por ejemplo usando la bandera `--noEmitOnError`


**Tipos explicitos o anotaciones**
Con las anotaciones describimos los tipos de nuestros valores. Aunque no siempre son necesarias, muchas veces TS es capaz de inferir los tipos en base a los valores.


---
INTERESTING TYPESCRIPT PROBLEM 

```TS

// eslint-disable-next-line @typescript-eslint/no-explicit-any

export const getObjValues = <T extends Record<string, unknown>>(

obj: T,

properties = [],

) => {

if (typeof obj === 'object') {

Object.values(obj).forEach((primitiveOrObject) => {

if (typeof primitiveOrObject === 'object' && primitiveOrObject !== null) {

getObjValues(primitiveOrObject as Record<string, unknown>, properties);

}

});

} else {

properties.push(obj);

}

  

return properties;

};

  

// expect(

// getObjValues({

// label: 'hello',

// numbers: {

// first: 1,

// second: 2,

// },

// }),

// ).toEqual(['hello', 1, 2]);
```
