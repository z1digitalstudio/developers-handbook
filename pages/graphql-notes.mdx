# Notas sobre el uso de Graphql en los proyectos

---
- üá™üá∏ Idioma: Espa√±ol
- üò∏ Autores: Alejandro P√°ez, Dani Marcano, Fran Naranjo, Ana Menacho, Mar√≠a Sim√≥
- üóìÔ∏è Creado: 07/02/2023

---


## TL;DR
- Cambiamos la configuraci√≥n de Codegen. Ahora nos vamos a apoyar en un plugin que se llama `typed-document-node`
- La configuraci√≥n de Codegen la vamos a escrbir en .ts, como recomienda la documentaci√≥n. 
- Dejamos de escribir las queries en archivos .ts, usaremos archivos .graphql
- Proponemos el uso de dos extensiones para tener autocompletado en nuestras queries y mutaciones
- M√°s otras recomendaciones y tips para integrar GraphQL en nuestros proyectos


## ¬øQu√© es Codegen y c√≥mo lo usamos?

**Graphql Codegen** (en adelante *Codegen*) es una herramienta que utilizamos en los proyectos que nos permite generar tipos a partir del schema de GraphQL que nos proporciona backend.

En los √∫ltimos proyectos estamos trabajando con **distintas configuraciones de la herramienta**, para probar qu√© nos funciona mejor:

#### Con Gql

Durante mucho tiempo, hemos configurado Codegen con los plugins `typescript` y `typescript-operations` para generar un archivo de tipos.  Luego cre√°bamos nuestras queries y mutaciones usando `gql` "a mano" en documentos `.ts`. 

```ts
import { gql } from '@apollo/client'; 
import type { TypedDocumentNode } from '@apollo/client';
import type { MeChannelsQuery, MeChannelsQueryVariables } from 'graphql/generated';

const ME_CHANNELS: TypedDocumentNode<MeChannelsQuery, MeChannelsQueryVariables> = gql`
query MeChannels($communityId: UUID!) {
	meChannels(communityId: $communityId) {
		id
		name
	}
}`;

export default ME_CHANNELS;
	```

Esta sintaxis es bastante complicada: creamos una constante, tenemos que tiparla con gen√©ricos que importamos, y usar el template literal `gql` para escribir en grapqhl.

Si adem√°s queremos hacer uso de un fragmento en la query, debemos importarlo y declararlo al final de la query.

```ts
import { gql } from '@apollo/client'; 
import type { TypedDocumentNode } from '@apollo/client';
import type { MeChannelsQuery, MeChannelsQueryVariables } from 'graphql/generated';
import AVATAR_FRAGMENT from 'graphql/fragments/Avatar';

const ME_CHANNELS: TypedDocumentNode<MeChannelsQuery, MeChannelsQueryVariables> = gql`
query MeChannels($communityId: UUID!) {
	meChannels(communityId: $communityId) {
		id
		name
		avatar {
			...Avatar
		}
	}
}
${AVATAR_FRAGMENT}
`;

export default ME_CHANNELS;
```

> Proyectos de ejemplo:  `Console`, `Connekt` y muchos otros.



#### Con Typescript React Apollo

El plugin `typescript-react-apollo` nos ha servido para generar nuevos tipos que nos han permitido usar Apollo m√°s c√≥modamente. Este plugin genera documentos tipados a partir del esquema, del tipo `MyQueryDocument` as√≠ como otras utilidades relacionadas con Apollo como cliente de Graphql.

Podemos configurar el plugin para usar los tipos en diferentes grados de dependencia.

1. **Con documentos tipados**

Un documento tipado contiene una llamada al esquema (una query, una mutaci√≥n), usando el template literal `gql`. Es decir genera para nosotros algo muy similar a lo que antes tip√°bamos a mano. 

Ya no escribimos la query como lo hac√≠amos en el caso anterior, podemos escribir directamente nuestras operaciones en archivos `.graphql` o `.gql`. Codegen va a interpretarlos y generar a partir de ellos los documentos tipados. En queries, tenemos algo como: 

```graphql

query getMe {
	me {
		id
		name
		avatar {
			...Avatar
		}
	}
}

```

Para usar un fragmento simplemente, lo escribimos y lo usamos. No necesitamos importar, porque graphql es capaz de encontrarlo. 
Codegen generar√° un `GetMeDocument` y tipos relacionados que luego podemos usar directamente en nuestros hooks de Apollo. Los datos que devuelva el hook estar√°n correctamente tipados. 


```ts
const { data } = useQuery<
  GetMeQuery,
  // no es necesario especificar si la query no recibe variables
  GetMeQueryVariables 
>(GetMeDocument);
```


>  Projectos de ejemplo: `Dreamlab`, `Baselang`


2. **Con documentos tipados y hooks**

Este plugin genera por defecto hooks de Apollo listos para usar. Por ejemplo, a partir de la query anterior, generar√≠a algo como `useGetMeQuery` y `useGetMeLazyQuery`, que podemos usar directamente en los hooks connect de nuestras vistas. Esta configuraci√≥n puede ser √∫til para proyectos peque√±os donde queramos que prime la agilidad, y reducir el boilerplate que escribimos. A cambio sacrificamos la independencia del frontend, estamos m√°s acoplados a Apollo. 

>  Projectos de ejemplo: `Tipz`, `Pira`



### Typed document node

[Typed document node](https://the-guild.dev/graphql/codegen/plugins/typescript/typed-document-node)  (TDN) es otro plugin que funciona de manera similar a  Typescript React Apollo, tambi√©n genera documentos tipados a partir de nuestras queries y mutaciones escritas en `.graphql`. Presenta una ventaja adicional, que es un tipado mucho m√°s sencillo cuando usamos los documentos generados en los hooks de Apollo. 

- `typescript-apollo-react`

```ts
const [
  performCancelAppointment,
  { loading: cancelAppointmentAppointmentsLoading },
] = useMutation<
  CancelAppointmentMutation,
  CancelAppointmentMutationVariables
>(CancelAppointmentDocument, { refetchQueries: ['GetMyAppointments'] });
```

- `typed-document-node`

```ts
const [
  performCancelAppointment,
  { loading: cancelAppointmentAppointmentsLoading },
] = useMutation(CancelAppointmentDocument, {
  refetchQueries: ['GetMyAppointments'],
});
```

Con Typescript React Apollo necesitamos pasar al hook uno o dos tipos gen√©ricos, para que los datos retornados est√©n tipados correctamente. Con Typed Document Node, no es necesario, y nuestra llamada queda mucho m√°s limpia. 

Adem√°s, este plugin trae un par de [tipos](https://github.com/dotansimha/graphql-typed-document-node#how-to-use) que nos pueden ser de utilidad: `VariablesOf<typeof MyQueryDocument>` y `ResultOf<typeof MyQueryDocument>`

> Projectos de ejemplo: `Longevity`

> [Gu√≠a de Graphql Codegen sobre este plugin ](https://the-guild.dev/blog/typed-document-node)


### Client Preset

Existen otras opciones en el horizonte. Parece de los mantainers de GraphQL Codegen est√°n empezando a apuntar el uso de otro tipo de configuraci√≥n: `client-preset`, que van a priorizar en su roadmap y que usa, entre otras cosas, TDN por debajo. De hecho, es la configuraci√≥n que est√°n recomendando en [su gu√≠a de inicio de React](https://the-guild.dev/graphql/codegen/docs/guides/react-vue). Si visitas [el repo de TDN](https://github.com/dotansimha/graphql-typed-document-node#how-to-use) tambi√©n te redirigen a esta opci√≥n.

A√∫n no lo hemos probado en ning√∫n proyecto, y parece que el cambio de un tipo de configuraci√≥n a otra no es trivial y afecta a la estructura de archivos, a la forma c√≥mo se escriben las operaciones, etc. Es una propuesta reciente, con lo cual no hay ninguna prisa para adoptarla, pero est√° bien saber que existe y podr√≠amos considerarla para alg√∫n proyecto:

M√°s informaci√≥n:
- [Issue Graphql Codegen Roadmap](https://github.com/dotansimha/graphql-code-generator/issues/8296)



## Configuraci√≥n de Codegen

El plugin que vamos a usar de manera estable a partir de ahora en nuestros proyectos va a ser el de **Typed Document Node**. Necesitamos instalar las siguientes dependencias: 

```bash
@graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typed-document-node 
```

En cuanto a nuestro archivo de Configuraci√≥n, sugiero que **nos movamos de la extensi√≥n `.yml` a la `.ts`** que tambi√©n permite Codegen y actualmente recomienda en su documentaci√≥n. Los archivos Yaml son m√°s tendentes a error, mientras que un archivo de Typescript es m√°s reconocible y f√°cil de leer, y tiene opciones de autocompletado. Nuestra configuraci√≥n quedar√≠a m√°s o menos as√≠:

```ts
// codegen.ts

import type { CodegenConfig } from '@graphql-codegen/cli';

const config: CodegenConfig = {
	schema: [
		`${process.env.NEXT_PUBLIC_GRAPHQL_ENDPOINT ?? ''}`,
		'schema.client.graphql/',
	],
	documents: ['src/graphql/**/*.graphql'],
	generates: {
		'./src/graphql/generated/types.ts': {
			plugins: [
				'typescript',
				'typescript-operations',
				'typed-document-node',
			],
			config: {
				scalars: {
					Date: 'string',
					DateTime: 'string',
					GenericScalar: 'unknown',
					Upload: 'unknown',
					UUID: 'string',
					Decimal: 'number',
					JSONString: 'string',
				},
				strictScalars: true,
				skipTypename: true,
				maybeValue: 'T | undefined',
			},
		},
		'./src/graphql/generated/introspection.ts': {
			plugins: ['fragment-matcher'],
		},
		'./src/graphql/generated/schema.graphql': {
			plugins: ['schema-ast'],
		},
	},
	hooks: {
		afterAllFileWrite: 'prettier --write',
	},
};

export default config;
```

Vamos a analizar qu√© tenemos aqu√≠:

- `schema`. Especificamos a partir de qu√© schemas queremos generar nuestros tipos. Normalmente solo tendremos uno, la api url que nos proporciona backend. Si adem√°s queremos trabajar con [client fields](#client-fields) (spoiler: normalmente no lo haremos), podemos especificar un esquema en el lado del cliente.
- `documents`: Uno o varios *globs* especificando en qu√© rutas est√°n nuestras queries, mutaciones, fragmentos y suscripciones, que Codegen usar√° para generar los tipos.
- `generates`: Lista con los documentos que queremos generar cada vez que ejecutemos el comando de Codegen. El m√°s importante de los archivos que generamos es `types.ts`.
	- `types.ts`. Aqu√≠ se generan los documentos tipados de los que hablamos anteriormente. Para configurar c√≥mo queremos generar este archivo, tenemos un objeto donde especificamos qu√© plugins vamos a usar y que configuraci√≥n va a tener cada plugin. Vemos algunas opciones interesantes como `maybeValue: 'T | undefined'` que quita los nulls de nuestros tipos (algo que antes ten√≠amos que hacer manualmente en el paso de la normalizaci√≥n). Pod√©is consultar el resto en la documentaci√≥n:
		- [Opciones](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript) de configuraci√≥n de `typescript`
		- [Opciones](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript-operations) de configuraci√≥n de `typescript-operations`:
		- [Opciones](https://the-guild.dev/graphql/codegen/plugins/typescript/typed-document-node) de configuraci√≥n de `typed-document-node`
	- `introspection.ts`. El archivo de introspecci√≥n es un archivo importante pero con el que no vamos a trabajar directamente en el c√≥digo de nuestra aplicaci√≥n. B√°sicamente usamos un plugin adicional, `fragment-matcher` para que Apollo entienda las uniones e interfaces de GraphQL. El archivo generado simplemente lo pasamos al cliente de Apollo cuando lo instanciemos bajo la key `possibleTypes`, y no tenemos que hacer nada m√°s al respecto. M√°s informaci√≥n: 
		- https://the-guild.dev/graphql/codegen/plugins/other/fragment-matcher
		- https://www.apollographql.com/docs/react/data/fragments/#using-fragments-with-unions-and-interfaces
	- `schema.graphql`. Un tercer archivo que podemos general es el schema de back en nuestro front. Lo podemos hacer gracias a otro plugin, `schema-ast`. Tener el schema en front nos permite una mejor experiencia de desarrollo (ver [Extensiones](#Extensiones))
- `hooks`. Por √∫ltimo, de la misma manera que existen hooks para .git que nos permiten realizar acciones en ciertos momentos del ciclo de git, tambi√©n tenemos [lifecycle hooks](https://the-guild.dev/graphql/codegen/docs/config-reference/lifecycle-hooks) para codegen. En este caso, formateamos con prettier despu√©s de generar los archivos. 

## Otras configuraciones adicionales

Adem√°s del archivo `codegen.ts`, necesitamos configurar otro par de aspectos:

### Scripts

En nuestro `package.json`, a√±adimos un script para correr la linea de comandos de Codegen y generar todos los archivos que especificamos en el archivo de configuraci√≥n:

```json

"scripts": {
	"gen": "dotenv -c development -- graphql-codegen",
	"gen:watch": "yarn gen -- --watch"
}

```

- Necesitamos `dotenv` como dependencia para poder usar las variables de entorno de nuestro .env en el archivo de configuraci√≥n de Codegen.
- Tambi√©n podemos crear un script con el *watch mode* activado, y tenerlo corriendo en un segundo plano mientras desarrollamos. De esta manera no tenemos que ejecutar el comando cada vez que queramos actualizar nuestros tipos. 

### Extensiones

Para tener *syntax highlighting* y autocompletado en nuestras operaciones de graphql, podemos instalar las siguientes extensiones (para VSCode):
- [Graphql: Syntax Highlighting](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql-syntax)
- [Graphql: Language Feature Support](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql)
	üö® Existen dos extensiones con el mismo nombre, instalad la que tiene un mayor n√∫mero de descargas

Para activar el autocompletado, necesitamos crear un archivo de configuraci√≥n donde vamos a indicar la ruta del `schema.graphql` que generamos antes con Codegen:

```json
// .graphqlconfig

{
	"schemaPath": "./src/graphql/generated/schema.graphql"
}
```

De esta manera, tendremos un error si escribimos un campo que no existe en nuestra query, recibiremos sugerencias al escribir y tambi√©n podemos ver todas los campos disponibles con el shortcut `crtl + space`.


![Graphql Suggestions](graphql-autocomplete-suggestions.png)

![Graphql Error](graphql-autocomplete-error.png)


## FAQ

### ¬øC√≥mo y donde usar los tipos que genera Codegen?

Podemos usar los tipos de Codegen en nuestros hooks de GraphQL y en nuestras vistas. En cambio, los componentes que viven en la carpeta `/componentes` son componentes presentacionales. Hay que pensar en ellos como piezas at√≥micas de un sistema, hechas para reusarse y encajar en diferentes contextos, y por tanto, agn√≥sticas de los detalles del dominio de la aplicaci√≥n. La idea es que deber√≠amos poder ser capaces de copiarlas y pegarlas en otro proyecto y que funcionasen. Por tanto las interfaces de estos componentes las vamos a tipar manualmente.


### ¬øQu√© pasa con la normalizaci√≥n?

Cuando creamos un hook que consume una query o mutaci√≥n, podemos normalizar los datos antes de devolverlos, para que sea m√°s f√°cil que sean consumidos por nuestras vistas y componentes.  

Pero vamos a dejar de hacerlo como [cargo cult](https://en.wikipedia.org/wiki/Cargo_cult_programming?useskin=vector):  es decir, como un boilerplate que a√±adimos en cada uno de nuestros hooks de Graphql porque *lo hacemos siempre as√≠*, aunque no sepamos muy bien cu√°l es su prop√≥sito.

Ejemplo donde tiene sentido una normalizaci√≥n: 
- Cuando necesitamos:
	- Computar nuevos campos
	- Hacer c√°lculos con nuestros datos porque siempre los vamos a consumir as√≠
	- Renombrar campos para que se ajusten a las interfaces que tenemos en front

```ts
  
export const useTeacherCards = () => {
	const { data, loading, fetchMore } = useQuery(GetTeacherCardsDocument);

	const normalizeTeacher = ({
		avatar,
		country,
		name: fullName,
		currentRating,
		dele,
		realWorld,
		interests,
	}) => ({
		avatar: {
			url: avatar,
			flag: country?.image,
			country: country?.nationality,
		},
		name: capitalizeAll(fullName),
		rating: currentRating,
		programs: getPrograms({ dele, realWorld }),
		tags: [
			...interests.map(({ name }) => name),
		].filter(isString).map(capitalize),
	}),

	const teacherList = data?.teachers.edges.map(normalizeTeacher)
	
	return {
		teachers: {
			edges: teacherList,
			pageInfo: data?.teachers.pageInfo,
		},
	};
```

Ejemplo donde tiene menos sentido una normalizaci√≥n: 
- Cogemos todos los campos del resultado de una query y los pasamos por una funci√≥n normalizadora que no hace nada. A lo sumo pasa valores por defecto (cuidado con esto porque podemos enmascarar los tipos reales de nuestros datos de una forma no deseada): 

```ts
  
export const useTeacherCards = () => {
	const { data, loading, fetchMore } = useQuery(GetTeacherCardsDocument);

	const normalizeTeacher = ({
		avatar,
		country,
		name: fullName,
		currentRating,
		interests,
	}) => ({
		avatar: avatar ?? "",
		name: name ?? "",
		currentRating: currentRating ?? 0,
		interests: interests ?? []
	}),

	const teacherList = data?.teachers.edges.map(normalizeTeacher)
	
	return {
		teachers: {
			edges: teacherList,
			pageInfo: data?.teachers.pageInfo,
		},
	};
```

Todo el proceso de la normalizaci√≥n se facilita mucho cuando seguimos una filosof√≠a de crear queries peque√±as y ad hoc para nuestras visitas, porque as√≠ no necesitamos que el resultado de la normalizaci√≥n "encaje" en interfaces de componentes muy dispares entre s√≠.


### ¬øQu√© pasa con los fragmentos?

Con los fragmentos ha pasado algo parecido que con la normalizaci√≥n, se han convertido en un h√°bito que se reproduce ciegamente. Cuando debemos usar los fragmentos:
- **No** para escribir menos cuando los campos se repiten. Si hacemos esto tenemos que tener mucho cuidado, porque empezamos a tirar de fragmentos que a su vez pueden usar fragmentos y es muy f√°cil caer en el *overfetching* y el las dependencias circulares.
- **S√≠** para vincular en cach√© dos operaciones que devuelven los mismos datos:

Ejemplo de uso de fragmento:

```gql
fragment StudentState on UserType {
	student {
		id
		currentProgram
		currentSubscription {
			id
			plan {
				id
				product
			}
		}
	}
}
```

El fragmento se usa, por ejemplo, en la query `me`:

```
query getMe {
	me {
		id
		email
		...StudentState
	}
}
```

Pero tambi√©n como resultado de las mutaciones de `login` , `refresh` o de `assignPlan`. De esta manera, Apollo sabr√° que debe actualizar las entradas de la cach√© relativas a `me` despu√©s de realizar estas mutaciones. [M√°s informaci√≥n](https://www.apollographql.com/docs/react/data/mutations/#include-modified-objects-in-mutation-responses)

```
mutation assignOnlinePlan($input: AssignOnlinePlanInput!) {
	assignOnlinePlan(input: $input) {
		refreshToken
		token
		user {
			id
			...StudentState
		}
	}
}
```

En general es una buena pr√°ctica pedir al equipo de backend que las mutaciones devuelvan los tipos que mutan. 

 
### ¬øQu√© estructura de directorios tienen que seguir nuestros archivos de GraphQL?

Actualmente estamos usando una estructura donde todo se agrupa de manera funcional, Por tanto, tenemos todo lo relativo a graphql junto en una carpeta con el mismo nombre. Dentro de esta carpeta tenemos:

- /graphql
	- client
	- queries
	- mutations
	- fragments
	- hooks

De momento, esto se mantiene as√≠, aunque es probable que en nuevos proyectos exploremos otras formas de organizaci√≥n m√°s cercanas a la `screaming architecture`, donde todo se agrupa por dominio, de manera que cuando miramos la estructura del proyecto tenemos una idea de qu√© va la aplicaci√≥n. 

En ese contexto, podr√≠a suceder que nuestras queries y mutaciones estuvieran dentro de una carpeta `features` , y que dentro de cada feature tuvi√©ramos las operaciones de graphql correspondientes dentro de una carpeta `data`. En esa carpeta tambi√©n tendr√≠amos el custom hook que las consume. 

- /features
	- /auth
		- queries
		- mutations
		- repository (hook y normalizaci√≥n)
	- /calendar
	- /classes
	- /lessons

> **¬øPor qu√© no hemos hecho esto todav√≠a?**
>
> Una agrupaci√≥n funcional es "m√°s f√°cil de entender", en el sentido de que para saber d√≥nde va cada cosa no tienes porqu√© conocer el dominio de la aplicaci√≥n. Tiene menor curva de aprendizaje. Por otra parte, en el modelo de agrupaci√≥n por dominio, las features no tienen porque corresponderse con las vistas, no tienen un reflejo exacto en la UI, y es m√°s dif√≠cil saber donde trazar las separaciones.
> 
> ¬øTe interesa este tema? [Haz una propuesta](https://developers-handbook.vercel.app/proposals/how-to-make-a-new-proposal)


### Client fields y otras features de Apollo 3

**Client fields**
En el apartado de configuraci√≥n de Codegen mencion√°bamos de pasada los client-fields. Los client fields son campos que a√±adimos a nuestras queries pero que no existen en el schema de backend, solo en el front. 

Son otra forma de crear estado local, con la ventaja de que todo pasa por el sistema de Apollo: no tenemos que calcular estos campos a partir de los datos que nos devuelve la query en nuestro hook de Graphql. Directamente podemos pedir  a una query un campo calculado que no existe en el servidor, y recibir resultados. 

Para definir un client field, usamos la directiva @client:

```gql

query getMe {
	me {
		firstName
		lastName
		initials @client
	}
}

```

[M√°s informaci√≥n](https://www.apollographql.com/docs/react/local-state/managing-state-with-field-policies/).

**Field policies**
Para resolver el campo `initials` de la query anterior necesitaremos definir una *field policy*. Es la manera en la que indicamos a Apollo qu√© es `initials` y c√≥mo calcularlo. Dentro de la cach√© de Apollo, definimos este nuevo campo y lo resolvemos:

```ts
const cache = new InMemoryCache({
  typePolicies: {
    UserType: {
      fields: { 
	     initials(_, { readField }) {
			const firstName = readField<string>('firstName') ?? '';
			const lastName = readField<string>('lastName') ?? '';
			return getInitials(firstName, lastName);
			},
	     }
	    }
	  }
});
```

> Proyectos: Este enfoque se ha usado en `Pira`. 

Las field policies de Apollo 3 son muy potentes y permiten crear estrategias de paginaci√≥n, personalizar c√≥mo se guardan las entradas en la cach√© de Apollo, etc. Links por si quieres investigar m√°s:

- Intro to Apollo Client 3.0. https://www.youtube.com/watch?v=ou0fEW1eRjc
- Fine tunning Apollo Client cache https://www.youtube.com/watch?v=n_j8QckQN5I
- Customizing the behavior of cached fields: https://www.apollographql.com/docs/react/caching/cache-field-behavior/
